package io.bazel.kotlin.generate

import io.bazel.kotlin.generate.WriteKotlincCapabilities.KotlincCapabilities.Companion.asCapabilities
import org.jetbrains.kotlin.arguments.description.CompilerArgumentsLevelNames
import org.jetbrains.kotlin.arguments.description.kotlinCompilerArguments
import org.jetbrains.kotlin.arguments.dsl.base.KotlinCompilerArgument
import org.jetbrains.kotlin.arguments.dsl.base.KotlinCompilerArgumentsLevel
import org.jetbrains.kotlin.arguments.dsl.base.KotlinReleaseVersion
import org.jetbrains.kotlin.arguments.dsl.types.BooleanType
import org.jetbrains.kotlin.arguments.dsl.types.IntType
import org.jetbrains.kotlin.arguments.dsl.types.KotlinVersion
import org.jetbrains.kotlin.arguments.dsl.types.StringArrayType
import org.jetbrains.kotlin.arguments.dsl.types.StringType
import java.nio.charset.StandardCharsets
import java.nio.file.FileSystems
import java.nio.file.Files
import java.time.Year
import kotlin.io.path.exists
import kotlin.io.path.writeText
import kotlin.math.max
import kotlin.streams.toList

/**
 * Generates a list of kotlinc flags from the kotlin-compiler-arguments-description artifact.
 * This artifact provides structured metadata about all compiler options including:
 * - Flag name and description
 * - Type information (boolean, string, string list)
 * - Lifecycle information (introduced version, stabilized version, deprecated version)
 */
object WriteKotlincCapabilities {

  private val BAZEL_HEADER = """
    |# Copyright ${Year.now()} The Bazel Authors. All rights reserved.
    |#
    |# Licensed under the Apache License, Version 2.0 (the "License");
    |# you may not use this file except in compliance with the License.
    |# You may obtain a copy of the License at
    |#
    |#    http://www.apache.org/licenses/LICENSE-2.0
    |#
    |# Unless required by applicable law or agreed to in writing, software
    |# distributed under the License is distributed on an "AS IS" BASIS,
    |# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    |# See the License for the specific language governing permissions and
    |# limitations under the License.
    |
    |# DO NOT EDIT: generated by bazel run //src/main/kotlin/io/bazel/kotlin/generate:kotlin_release_options
  """.trimMargin()

  @JvmStatic
  fun main(vararg args: String) {
    val options = parseOptions(args)

    val envPattern = Regex("\\$\\{(\\w+)}")
    val capabilitiesDirectory = options["--out"]
      ?.first()
      ?.let { env ->
        envPattern.replace(env) {
          System.getenv(it.groups[1]?.value)
        }
      }
      ?.run(FileSystems.getDefault()::getPath)
      ?.apply {
        if (!parent.exists()) {
          Files.createDirectories(parent)
        }
      }
      ?: error("--out is required")

    // Use kotlin-compiler-arguments-description artifact for compiler options metadata
    val capabilities = getArgumentsFromDescription()
      .filterNot(KotlincCapability::shouldSuppress)
      .asCapabilities()

    capabilitiesDirectory.resolve(capabilitiesName).writeText(
      capabilities.asCapabilitiesBzl().toString(),
      StandardCharsets.UTF_8,
    )

    // Generate opts file with full Starlark option structures
    capabilitiesDirectory.resolve(generatedOptsName).writeText(
      capabilities.asGeneratedOptsBzl(),
      StandardCharsets.UTF_8,
    )

    // Generate templates.bzl with both capabilities and generated_opts templates
    capabilitiesDirectory.resolve("templates.bzl").writeText(
      BzlDoc {
        assignment(
          "TEMPLATES",
          list(*listTemplateFiles(capabilitiesDirectory, "capabilities_")),
        )
        assignment(
          "GENERATED_OPTS_TEMPLATES",
          list(*listTemplateFiles(capabilitiesDirectory, "generated_opts_")),
        )
      }.toString(),
    )
  }

  private fun listTemplateFiles(directory: java.nio.file.Path, prefix: String): Array<String> =
    Files.list(directory)
      .filter { it.fileName.toString().startsWith(prefix) }
      .map { "Label(${it.fileName.bzlQuote()})" }
      .sorted()
      .toArray { arrayOfNulls<String>(it) }
      .toTypedArray()

  private fun parseOptions(args: Array<out String>): Map<String, List<String>> =
    args.asSequence()
      .flatMap { it.split("=", limit = 2) }
      .chunked(2)
      .filter { it.size == 2 }
      .groupBy({ it[0] }, { it[1] })

  /** Options that are either confusing, useless, or unexpected to be set outside the worker. */
  private val suppressedFlags = setOf(
    "-P",
    "-X",
    "-Xbuild-file",
    "-Xcompiler-plugin",
    "-Xdump-declarations-to",
    "-Xdump-directory",
    "-Xdump-fqname",
    "-Xdump-perf",
    "-Xintellij-plugin-root",
    "-Xplugin",
    "-classpath",
    "-d",
    "-expression",
    "-help",
    "-include-runtime",
    "-jdk-home",
    "-kotlin-home",
    "-module-name",
    "-no-jdk",
    "-no-stdlib",
    "-script",
    "-script-templates",
    // Flags that should be controlled by rules_kotlin, not user configuration
    "-Xfriend-paths",  // Internal module visibility - managed by rules_kotlin
    "-Xjava-source-roots",  // Managed by rules_kotlin based on deps
    "-Xjavac-arguments",  // Use kt_javac_options instead
    // Flags handled in MANUAL_KOPTS with custom logic - suppress to avoid duplicates
    "-jvm-target",  // Handled in MANUAL_KOPTS with specific allowed values
    // Flags that don't make sense in rules_kotlin context
    "-Xallow-no-source-files",  // Rules will fail before this flag is checked
    "-Xcompile-java",  // Java compilation happens via the java builder
    "-Xuse-javac",  // Java sources are compiled via a different pipeline
    "-Xuse-k2-kapt",  // kapt is explicitly supported via rules
    // Script-related flags - script compilation not supported by rules
    "-Xdefault-script-extension",
    "-Xdisable-standard-script",
    "-Xscript-resolver-environment",
    // Path-based flags that require explicit rule support
    "-Xklib",  // Cross-platform libraries need to be in action inputs
    "-Xmodule-path",  // Java 9+ modules need path handling
    "-Xprofile",  // Requires path input and produces outputs that would be lost
    // Flags that conflict with rules_kotlin behavior
    "-Xno-reset-jar-timestamps",  // Rules explicitly zero out timestamps
    "-Xoutput-builtins-metadata",  // Outputs would not be added to rule outputs
  )

  /**
   * Parse enumerated values from valueDescription.
   * The format is typically {value1|value2|value3} or {value1/value2/value3}.
   * Returns null if the valueDescription doesn't contain enumerated values.
   */
  private fun parseEnumeratedValues(valueDescription: String?): List<String>? {
    if (valueDescription.isNullOrBlank()) return null

    // Match pattern like {value1|value2|value3} or {value1/value2/value3}
    val match = Regex("^\\{([^}]+)}$").find(valueDescription.trim()) ?: return null
    val content = match.groupValues[1]

    // Split by | or / and filter out placeholders like <path>, <N>, etc.
    val values = content.split(Regex("[|/]"))
      .map { it.trim() }
      .filter { it.isNotBlank() && !it.startsWith("<") && !it.endsWith(">") }

    return if (values.size >= 2) values else null
  }

  /**
   * Derive the latest stable language version from KotlinVersion entries.
   * A version is stable if it has a non-null stabilizedVersion in its lifecycle metadata.
   */
  private val latestStableVersion: KotlinVersion by lazy {
    KotlinVersion.entries
      .filter { it.releaseVersionsMetadata.stabilizedVersion != null }
      .maxBy { it.releaseVersionsMetadata.stabilizedVersion!! }
  }

  val capabilitiesName: String by lazy {
    "capabilities_${latestStableVersion.versionName}.bzl.com_github_jetbrains_kotlin.bazel"
  }

  val generatedOptsName: String by lazy {
    "generated_opts_${latestStableVersion.versionName}.bzl.com_github_jetbrains_kotlin.bazel"
  }

  private class BzlDoc {
    private val header = Comment(BAZEL_HEADER)

    val contents: MutableList<Block> = mutableListOf()

    constructor(statements: BzlDoc.() -> Unit) {
      statement(header)
      apply(statements)
    }

    fun statement(vararg statements: Block) {
      contents.addAll(statements)
    }

    class Indent(val spaces: Int = 0) {
      fun increment() = Indent(spaces+2)
      fun decrement() = Indent(max(spaces - 2, 0))
      override fun toString() = " ".repeat(spaces)
      operator fun plus(s:String?) = toString() + s
    }

    fun interface Block {
      fun asString(indent: Indent): String?
      fun asString() = asString(Indent())
    }

    fun interface ValueBlock : Block {
      fun asString(indent: Indent, map: (String) -> String): String?
      override fun asString(indent: Indent) = asString(indent.increment()) { it }
    }

    class Comment(val contents: String) : Block {
      override fun asString(indent: Indent): String? = indent + contents
    }

    override fun toString() = contents.mapNotNull { it.asString() }.joinToString("\n")

    fun assignment(key: String, value: ValueBlock) {
      statement(
        Block { indent ->
          indent + value.asString(indent.increment()) { "$key = $it" }
        },
      )
    }

    fun struct(vararg properties: Pair<String, String?>) = ValueBlock { indent, format ->
      properties
        .mapNotNull { (key, value) ->
          value?.let { "$indent$key = $it" }
        }
        .joinToString(",\n", prefix = "struct(\n", postfix = "\n${indent.decrement()})")
        .run(format)
    }

    fun dict(vararg properties: Pair<String, ValueBlock>) = ValueBlock { indent, format ->
      properties
        .mapNotNull { (key, value) ->
          value.asString(indent.increment())
            ?.let { "$indent${key.bzlQuote()} : $it" }
        }
        .joinToString(",\n", prefix = "{\n", postfix = "\n${indent.decrement()}}")
        .run(format)
    }

    fun list(vararg items: String) = ValueBlock { indent, format ->
      items
        .joinToString(
            separator = ",\n",
            prefix = "[\n",
            postfix = "\n${indent.decrement()}]",
        ) { "$indent$it" }
        .run(format)
    }
  }

  /**
   * Extract compiler arguments from kotlin-compiler-arguments-description artifact.
   * This collects arguments from the path from topLevel to JVM arguments,
   * including common compiler arguments.
   */
  private fun getArgumentsFromDescription(): Sequence<KotlincCapability> = sequence {
    // Find the path from topLevel to jvmCompilerArguments
    val path = findPathToLevel(
      kotlinCompilerArguments.topLevel,
      CompilerArgumentsLevelNames.jvmCompilerArguments,
      mutableListOf()
    )
    if (path != null) {
      // Collect arguments from all levels in the path (common + JVM specific)
      for (level in path) {
        yieldAll(collectArgumentsFromLevel(level))
      }
    }
  }

  /**
   * Find a path from the current level to the target level.
   * Returns a list of levels from root to target (inclusive), or null if not found.
   */
  private fun findPathToLevel(
    level: KotlinCompilerArgumentsLevel,
    targetName: String,
    currentPath: MutableList<KotlinCompilerArgumentsLevel>
  ): List<KotlinCompilerArgumentsLevel>? {
    currentPath.add(level)
    if (level.name == targetName) return currentPath.toList()
    for (subLevel in level.nestedLevels) {
      findPathToLevel(subLevel, targetName, currentPath)?.let { return it }
    }
    currentPath.removeLast()
    return null
  }

  /**
   * Collect all arguments from a single level.
   */
  private fun collectArgumentsFromLevel(level: KotlinCompilerArgumentsLevel): Sequence<KotlincCapability> = sequence {
    for (arg in level.arguments) {
      yield(arg.toCapability())
    }
  }

  /**
   * Convert a KotlinCompilerArgument to our KotlincCapability.
   */
  private fun KotlinCompilerArgument.toCapability(): KotlincCapability {
    val defaultValue: String? = when (val vt = valueType) {
      is BooleanType -> vt.defaultValue.current?.let { if (it) "true" else "false" }
      is StringType -> vt.defaultValue.current
      is StringArrayType -> vt.defaultValue.current?.joinToString(",")
      is IntType -> vt.defaultValue.current?.toString()
      else -> null
    }

    val starlarkType = when (valueType) {
      is BooleanType -> StarlarkType.Bool
      is StringType -> StarlarkType.Str
      is StringArrayType -> StarlarkType.StrList
      is IntType -> StarlarkType.Str // Int represented as string in Starlark
      else -> StarlarkType.Str
    }

    // Extract enumerated values from valueDescription if available
    val enumValues = parseEnumeratedValues(valueDescription.current)

    return KotlincCapability(
      flag = "-$name",
      doc = description.current,
      default = defaultValue,
      type = starlarkType,
      enumeratedValues = enumValues,
      introducedVersion = releaseVersionsMetadata.introducedVersion.toString(),
      stabilizedVersion = releaseVersionsMetadata.stabilizedVersion?.toString(),
    )
  }

  private class KotlincCapabilities(val capabilities: Iterable<KotlincCapability>) {

    companion object {
      fun Sequence<KotlincCapability>.asCapabilities() = KotlincCapabilities(sorted().toList())
    }

    fun asCapabilitiesBzl() = BzlDoc {
      assignment(
        "KOTLIN_OPTS",
        dict(
          *capabilities.map { capability ->
            capability.flag to struct(
              "flag" to capability.flag.bzlQuote(),
              "doc" to capability.doc.bzlQuote(),
              "default" to capability.defaultStarlarkValue(),
              "introduced" to capability.introducedVersion?.bzlQuote(),
              "stabilized" to capability.stabilizedVersion?.bzlQuote(),
            )
          }.toTypedArray(),
        ),
      )
    }

    /**
     * Generate the full _KOPTS dict for opts.kotlinc.bzl.
     */
    fun asGeneratedOptsBzl(): String {
      val tq = "\"\"\""  // triple quote for Python docstrings
      val helperFunctions = """
def _map_string_flag(flag):
    ${tq}Create a mapper for string flags that passes value as flag=value.$tq
    def mapper(value):
        if not value:
            return None
        return [flag + "=" + value]
    return mapper

def _map_string_list_flag(flag):
    ${tq}Create a mapper for string list flags that passes each value as flag=value.$tq
    def mapper(values):
        if not values:
            return None
        return [flag + "=" + v for v in values]
    return mapper
"""
      val entries = capabilities.joinToString(",\n") { capability ->
        "    ${capability.starlarkAttrName().bzlQuote()}: ${capability.asOptStructString("    ")}"
      }
      return "$BAZEL_HEADER\n$helperFunctions\n\nGENERATED_KOPTS = {\n$entries\n}\n"
    }
  }

  data class KotlincCapability(
    val flag: String,
    val doc: String,
    private val default: String?,
    val type: StarlarkType,
    val enumeratedValues: List<String>? = null,
    val introducedVersion: String? = null,
    val stabilizedVersion: String? = null,
  ) : Comparable<KotlincCapability> {

    fun shouldSuppress() = flag in suppressedFlags

    fun defaultStarlarkValue(): String? = type.convert(default)

    /** Returns true if this option is considered experimental (not yet stabilized). */
    fun isExperimental(): Boolean = stabilizedVersion == null

    override fun compareTo(other: KotlincCapability): Int = flag.compareTo(other.flag)

    /**
     * Convert flag name to Starlark attribute name.
     * e.g., "-Xcontext-receivers" -> "x_context_receivers"
     *       "-java-parameters" -> "java_parameters"
     */
    fun starlarkAttrName(): String {
      return flag
        .removePrefix("-")
        .replace(Regex("^X"), "x_")  // -Xfoo -> x_foo (add underscore after x)
        .replace("-", "_")
        .lowercase()
    }

    /**
     * Generate the struct string for this option in _KOPTS format.
     * String options with enumerated values use the values list for analysis-time validation.
     */
    fun asOptStructString(indent: String): String {
      return when (type) {
        is StarlarkType.Bool -> buildOptStruct(
          attrType = "attr.bool",
          argsExtra = emptyMap(),
          valueToFlag = "{True: [\"$flag\"]}",
        )
        is StarlarkType.Str -> {
          val argsExtra = if (enumeratedValues != null) {
            val valuesStr = enumeratedValues.joinToString(", ") { "\"$it\"" }
            mapOf("values" to "[\"\",$valuesStr]")
          } else {
            mapOf("default" to (default?.bzlQuote() ?: "\"\""))
          }
          buildOptStruct(
            attrType = "attr.string",
            argsExtra = argsExtra,
            mapValueToFlag = "_map_string_flag(${flag.bzlQuote()})",
          )
        }
        is StarlarkType.StrList -> buildOptStruct(
          attrType = "attr.string_list",
          argsExtra = mapOf("default" to "[]"),
          mapValueToFlag = "_map_string_list_flag(${flag.bzlQuote()})",
        )
      }.prependIndent(indent)
    }

    private fun buildOptStruct(
      attrType: String,
      argsExtra: Map<String, String>,
      valueToFlag: String? = null,
      mapValueToFlag: String? = null,
    ): String {
      val argsEntries = buildList {
        add("doc = ${doc.bzlQuote()}")
        argsExtra.forEach { (key, value) -> add("$key = $value") }
      }.joinToString(",\n            ")

      return buildString {
        appendLine("struct(")
        appendLine("    flag = ${flag.bzlQuote()},")
        appendLine("    args = dict(")
        appendLine("        $argsEntries,")
        appendLine("    ),")
        appendLine("    type = $attrType,")
        if (valueToFlag != null) {
          appendLine("    value_to_flag = $valueToFlag,")
        } else {
          appendLine("    value_to_flag = None,")
          appendLine("    map_value_to_flag = $mapValueToFlag,")
        }
        append(")")
      }
    }
  }

  sealed class StarlarkType {
    abstract fun convert(value: String?): String

    data object Bool : StarlarkType() {
      override fun convert(value: String?): String = if (value == "true") "True" else "False"
    }

    data object Str : StarlarkType() {
      override fun convert(value: String?): String = value?.bzlQuote() ?: "None"
    }

    data object StrList : StarlarkType() {
      override fun convert(value: String?): String =
        value?.let { "default = [${it.bzlQuote()}]" } ?: "[]"
    }
  }

  private fun Any.bzlQuote(): String {
    var asString = toString()
    val quote = "\"".repeat(if ("\n" in asString || "\"" in asString) 3 else 1)
    return quote + asString + quote
  }
}

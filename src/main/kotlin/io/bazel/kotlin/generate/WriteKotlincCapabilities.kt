package io.bazel.kotlin.generate

import io.bazel.kotlin.generate.WriteKotlincCapabilities.KotlincCapabilities.Companion.asCapabilities
import org.jetbrains.kotlin.arguments.description.CompilerArgumentsLevelNames
import org.jetbrains.kotlin.arguments.description.kotlinCompilerArguments
import org.jetbrains.kotlin.arguments.description.removed.removedCommonCompilerArguments
import org.jetbrains.kotlin.arguments.description.removed.removedJvmCompilerArguments
import org.jetbrains.kotlin.arguments.dsl.base.KotlinCompilerArgument
import org.jetbrains.kotlin.arguments.dsl.base.KotlinCompilerArgumentsLevel
import org.jetbrains.kotlin.arguments.dsl.base.KotlinReleaseVersion
import org.jetbrains.kotlin.arguments.dsl.types.BooleanType
import org.jetbrains.kotlin.arguments.dsl.types.IntType
import org.jetbrains.kotlin.arguments.dsl.types.StringArrayType
import org.jetbrains.kotlin.arguments.dsl.types.StringType
import java.nio.charset.StandardCharsets
import java.nio.file.FileSystems
import java.nio.file.Files
import java.time.Year
import kotlin.io.path.exists
import kotlin.io.path.writeText
import kotlin.math.max
import kotlin.streams.toList

/**
 * Generates a list of kotlinc flags from the kotlin-compiler-arguments-description artifact.
 * This artifact provides structured metadata about all compiler options including:
 * - Flag name and description
 * - Type information (boolean, string, string list)
 * - Lifecycle information (introduced version, stabilized version, deprecated version)
 */
object WriteKotlincCapabilities {

  private val BAZEL_HEADER = """
    |# Copyright ${Year.now()} The Bazel Authors. All rights reserved.
    |#
    |# Licensed under the Apache License, Version 2.0 (the "License");
    |# you may not use this file except in compliance with the License.
    |# You may obtain a copy of the License at
    |#
    |#    http://www.apache.org/licenses/LICENSE-2.0
    |#
    |# Unless required by applicable law or agreed to in writing, software
    |# distributed under the License is distributed on an "AS IS" BASIS,
    |# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    |# See the License for the specific language governing permissions and
    |# limitations under the License.
    |
    |# DO NOT EDIT: generated by bazel run //src/main/kotlin/io/bazel/kotlin/generate:kotlin_release_options
  """.trimMargin()

  @JvmStatic
  fun main(vararg args: String) {
    val options = parseOptions(args)

    val envPattern = Regex("\\$\\{(\\w+)}")
    val capabilitiesDirectory = options["--out"]
      ?.first()
      ?.let { env ->
        envPattern.replace(env) {
          System.getenv(it.groups[1]?.value)
        }
      }
      ?.run(FileSystems.getDefault()::getPath)
      ?.apply {
        if (!parent.exists()) {
          Files.createDirectories(parent)
        }
      }
      ?: error("--out is required")

    // Get optional target version filter (for testing single versions)
    val targetVersionFilter = options["--target-version"]?.firstOrNull()

    // Get all arguments including removed ones for multi-version support
    val allArguments = getAllArguments().toList()

    // Determine which versions to generate
    val versionsToGenerate = if (targetVersionFilter != null) {
      val version = SUPPORTED_VERSIONS.find {
        "${it.major}.${it.minor}" == targetVersionFilter
      } ?: error("Unknown target version: $targetVersionFilter. Supported: ${SUPPORTED_VERSIONS.map { "${it.major}.${it.minor}" }}")
      listOf(version)
    } else {
      SUPPORTED_VERSIONS
    }

    // Generate files for each supported version
    for (targetVersion in versionsToGenerate) {
      val capabilities = allArguments
        .filter { shouldGenerate(it, targetVersion) }
        .map { it.toCapability() }
        .asCapabilities()

      // Generate capabilities file
      capabilitiesDirectory.resolve(capabilitiesName(targetVersion)).writeText(
        capabilities.asCapabilitiesBzl().toString(),
        StandardCharsets.UTF_8,
      )

      // Generate opts file (only for Kotlin 2.0+)
      if (targetVersion >= KotlinReleaseVersion.v2_0_0) {
        capabilitiesDirectory.resolve(generatedOptsName(targetVersion)).writeText(
          capabilities.asGeneratedOptsBzl(),
          StandardCharsets.UTF_8,
        )
      }

      println("Generated files for Kotlin ${targetVersion.major}.${targetVersion.minor}")
    }

    // Generate templates.bzl with both capabilities and generated_opts templates
    capabilitiesDirectory.resolve("templates.bzl").writeText(
      BzlDoc {
        assignment(
          "TEMPLATES",
          list(*listTemplateFiles(capabilitiesDirectory, "capabilities_")),
        )
        assignment(
          "GENERATED_OPTS_TEMPLATES",
          list(*listTemplateFiles(capabilitiesDirectory, "generated_opts_")),
        )
      }.toString(),
    )
  }

  private fun listTemplateFiles(directory: java.nio.file.Path, prefix: String): Array<String> =
    Files.list(directory)
      .filter { it.fileName.toString().startsWith(prefix) }
      .map { "Label(${it.fileName.bzlQuote()})" }
      .sorted()
      .toList()
      .toTypedArray()

  private fun parseOptions(args: Array<out String>): Map<String, List<String>> =
    args.asSequence()
      .flatMap { it.split("=", limit = 2) }
      .chunked(2)
      .filter { it.size == 2 }
      .groupBy({ it[0] }, { it[1] })

  /** Options that are either confusing, useless, or unexpected to be set outside the worker. */
  private val suppressedFlags = setOf(
    "-P",
    "-X",
    "-Xbuild-file",
    "-Xcompiler-plugin",
    "-Xdump-declarations-to",
    "-Xdump-directory",
    "-Xdump-fqname",
    "-Xdump-perf",
    "-Xintellij-plugin-root",
    "-Xplugin",
    "-classpath",
    "-d",
    "-expression",
    "-help",
    "-include-runtime",
    "-jdk-home",
    "-kotlin-home",
    "-module-name",
    "-no-jdk",
    "-no-stdlib",
    "-script",
    "-script-templates",
    // Flags that should be controlled by rules_kotlin, not user configuration
    "-Xfriend-paths",  // Internal module visibility - managed by rules_kotlin
    "-Xjava-source-roots",  // Managed by rules_kotlin based on deps
    "-Xjavac-arguments",  // Use kt_javac_options instead
    // Flags handled in MANUAL_KOPTS with custom logic - suppress to avoid duplicates
    "-jvm-target",  // Handled in MANUAL_KOPTS with specific allowed values
    // Flags that don't make sense in rules_kotlin context
    "-Xallow-no-source-files",  // Rules will fail before this flag is checked
    "-Xcompile-java",  // Java compilation happens via the java builder
    "-Xuse-javac",  // Java sources are compiled via a different pipeline
    "-Xuse-k2-kapt",  // kapt is explicitly supported via rules
    // Script-related flags - script compilation not supported by rules
    "-Xdefault-script-extension",
    "-Xdisable-standard-script",
    "-Xscript-resolver-environment",
    // Path-based flags that require explicit rule support
    "-Xklib",  // Cross-platform libraries need to be in action inputs
    "-Xmodule-path",  // Java 9+ modules need path handling
    "-Xprofile",  // Requires path input and produces outputs that would be lost
    // Flags that conflict with rules_kotlin behavior
    "-Xno-reset-jar-timestamps",  // Rules explicitly zero out timestamps
    "-Xoutput-builtins-metadata",  // Outputs would not be added to rule outputs
  )

  /**
   * Flag policy for allowlist-based generation with multi-version support.
   * Based on design doc: docs/design/kotlinc_options_multi_version.md
   */
  object FlagPolicy {
    /**
     * Flags that must NEVER be exposed regardless of any other consideration.
     * These are managed by rules_kotlin, require path handling, or conflict with rules behavior.
     */
    val SUPPRESSED = setOf(
      // === Managed by rules_kotlin ===
      "-classpath",              // Set by compilation action
      "-d",                      // Output directory set by rules
      "-module-name",            // Set by rules from target name
      "-Xfriend-paths",          // Use `associates` attribute instead
      "-no-jdk",                 // JDK management is rules' job
      "-no-stdlib",              // Part of include_stdlibs abstraction
      "-no-reflect",             // Part of include_stdlibs abstraction

      // === Path-based flags (need action input handling) ===
      "-jdk-home",               // JDK managed by toolchain
      "-kotlin-home",            // Kotlin managed by rules
      "-Xplugin",                // Plugins via kt_compiler_plugin
      "-Xcompiler-plugin",       // Plugins via kt_compiler_plugin
      "-P",                      // Plugin options via kt_compiler_plugin
      "-Xklib",                  // Would need action inputs
      "-Xmodule-path",           // Java 9+ modules need explicit handling
      "-Xprofile",               // Would produce untracked outputs

      // === Java compilation (separate pipeline) ===
      "-Xjavac-arguments",       // Use kt_javac_options
      "-Xjava-source-roots",     // Java sources compiled separately
      "-Xcompile-java",          // Java via java builder
      "-Xuse-javac",             // Java via java builder
      "-Xjava-package-prefix",   // Java compilation separate

      // === Script compilation (not supported) ===
      "-script",
      "-script-templates",
      "-expression",
      "-Xdefault-script-extension",
      "-Xdisable-standard-script",
      "-Xscript-resolver-environment",

      // === Conflicts with rules_kotlin behavior ===
      "-Xno-reset-jar-timestamps",   // Rules explicitly zero timestamps
      "-Xoutput-builtins-metadata",  // Outputs not added to rule outputs
      "-Xallow-no-source-files",     // Rules validate sources exist

      // === Kapt (explicitly supported via rules) ===
      "-Xuse-k2-kapt",

      // === Fragment flags (complex multiplatform, hard to use correctly) ===
      "-Xfragments",
      "-Xfragment-sources",
      "-Xfragment-refines",
      "-Xfragment-dependency",
      "-Xfragment-friend-dependency",

      // === Internal/debugging (not useful for users) ===
      "-Xbuild-file",
      "-Xdump-declarations-to",
      "-Xdump-directory",
      "-Xdump-fqname",
      "-Xdump-perf",
      "-Xintellij-plugin-root",
      "-help",
      "-X",
      "-version",                // Just displays version
      "-Xrepl",                  // REPL mode
    )

    /**
     * Flags approved for automatic generation. Only flags in this set AND not in SUPPRESSED
     * will be generated. Organized by category for easier review.
     */
    val ALLOWLIST: Set<String>
      get() = BOOLEAN_FLAGS + ENUM_FLAGS + STRING_FLAGS + STRING_LIST_FLAGS

    /** Boolean flags (simple enable/disable) */
    private val BOOLEAN_FLAGS = setOf(
      // Nullability & Type Safety
      "-Xenhance-type-parameter-types-to-def-not-null",
      "-Xtype-enhancement-improvements-strict-mode",
      "-Xno-call-assertions",
      "-Xno-param-assertions",
      "-Xno-receiver-assertions",
      "-Xno-unified-null-checks",

      // Language Features
      "-Xcontext-receivers",
      "-Xcontext-parameters",
      "-Xinline-classes",
      "-Xvalue-classes",
      "-Xmulti-platform",
      "-Xexpect-actual-classes",
      "-Xexplicit-backing-fields",
      "-Xwhen-guards",
      "-Xnon-local-break-continue",
      "-Xnested-type-aliases",
      "-Xmulti-dollar-interpolation",
      "-Xannotation-target-all",
      "-Xdata-flow-based-exhaustiveness",
      "-Xallow-kotlin-package",
      "-Xconsistent-data-class-copy-visibility",
      "-Xcontext-sensitive-resolution",
      "-Xdirect-java-actualization",

      // Contracts
      "-Xallow-condition-implies-returns-contracts",
      "-Xallow-contracts-on-more-functions",
      "-Xallow-holdsin-contract",

      // Code Generation
      "-java-parameters",
      "-Xemit-jvm-type-annotations",
      "-Xmultifile-parts-inherit",
      "-Xno-new-java-annotation-targets",
      "-Xsanitize-parentheses",
      "-Xindy-allow-annotated-lambdas",
      "-Xjvm-enable-preview",
      "-Xjvm-expose-boxed",
      "-Xannotations-in-metadata",

      // Compilation Behavior
      "-progressive",
      "-verbose",
      "-Werror",
      "-Wextra",
      "-nowarn",
      "-Xno-inline",
      "-Xno-optimize",
      "-Xskip-metadata-version-check",
      "-Xskip-prerelease-check",
      "-Xallow-unstable-dependencies",
      "-Xgenerate-strict-metadata-version",
      "-Xreport-all-warnings",
      "-Xdont-warn-on-error-suppression",
      "-Xsuppress-version-warnings",
      "-Xsuppress-deprecated-jvm-target-warning",
      "-Xsuppress-missing-builtins-error",
      "-Xsuppress-api-version-greater-than-language-version-error",
      "-Xrender-internal-diagnostic-names",
      "-Xignore-const-optimization-errors",
      "-Xunrestricted-builder-inference",

      // IR & Backend
      "-Xuse-k2",
      "-Xnew-inference",
      "-Xir-inliner",
      "-Xir-do-not-clear-binding-context",
      "-Xuse-fast-jar-file-system",
      "-Xuse-fir-ic",
      "-Xuse-fir-lt",
      "-Xuse-fir-experimental-checkers",
      "-Xuse-inline-scopes-numbers",
      "-Xuse-type-table",
      "-Xuse-14-inline-classes-mangling-scheme",
      "-Xlink-via-signatures",
      "-Xvalidate-bytecode",
      "-Xuse-old-class-files-reading",
      "-Xmetadata-klib",
      "-Xenhanced-coroutines-debugging",

      // Debugging & Profiling
      "-Xdebug",
      "-Xcheck-phase-conditions",
      "-Xlist-phases",
      "-Xprofile-phases",
      "-Xreport-perf",
      "-Xdetailed-perf",
      "-Xreport-output-files",
      "-Xverify-ir-visibility",

      // Multiplatform
      "-Xno-check-actual",
      "-Xseparate-kmp-compilation",

      // Stdlib compilation (internal use)
      "-Xstdlib-compilation",
      "-Xcompile-builtins-as-part-of-stdlib",

      // Scripting (partial support)
      "-Xallow-any-scripts-in-source-roots",
      "-Xdisable-default-scripting-plugin",

      // Experimental/Advanced
      "-Xenable-incremental-compilation",
      "-XXlenient-mode",
      "-XXdebug-level-compiler-checks",
      "-Xallow-reified-type-in-catch",
    )

    /** Enum flags (with restricted values extracted from valueDescription) */
    private val ENUM_FLAGS = setOf(
      // Nullability handling
      "-Xjspecify-annotations",

      // Code generation schemes
      "-Xlambdas",
      "-Xsam-conversions",
      "-Xstring-concat",
      "-Xwhen-expressions",

      // JVM default methods
      "-jvm-default",
      "-Xjvm-default",  // Deprecated but still present

      // Assertions
      "-Xassertions",

      // API visibility
      "-Xexplicit-api",
      "-XXexplicit-return-types",

      // IR
      "-Xserialize-ir",
      "-Xverify-ir",
      "-Xabi-stability",

      // Return value checker
      "-Xreturn-value-checker",

      // Destructuring
      "-Xname-based-destructuring",

      // Annotation targets
      "-Xannotation-default-target",
    )

    /** String flags (free-form values) */
    private val STRING_FLAGS = setOf(
      "-api-version",
      "-language-version",
      "-Xmetadata-version",
      "-Xsupport-compatqual-checker-framework-annotations",
      "-XXdump-model",
    )

    /** String list flags (multiple free-form values) */
    private val STRING_LIST_FLAGS = setOf(
      "-opt-in",
      "-Xjsr305",
      "-Xnullability-annotations",
      "-Xadd-modules",
      "-Xcommon-sources",
      "-Xsuppress-warning",
      "-Xwarning-level",
      "-Xcompiler-plugin-order",
      "-XXLanguage",

      // Phase manipulation (debugging)
      "-Xdisable-phases",
      "-Xphases-to-dump",
      "-Xphases-to-dump-before",
      "-Xphases-to-dump-after",
      "-Xphases-to-validate",
      "-Xphases-to-validate-before",
      "-Xphases-to-validate-after",
      "-Xverbose-phases",
    )
  }

  /**
   * Supported Kotlin versions for multi-version generation.
   * We generate separate capabilities and generated_opts files for each version.
   * Only Kotlin 2.0+ is supported.
   */
  val SUPPORTED_VERSIONS = listOf(
    KotlinReleaseVersion.v2_0_0,
    KotlinReleaseVersion.v2_1_0,
    KotlinReleaseVersion.v2_2_0,
    KotlinReleaseVersion.v2_3_0,
  )

  /**
   * Check if a flag should be included in the generated files for a target version.
   * A flag is included if:
   * - It was introduced by or before the target version
   * - It has not been removed, or was removed after the target version
   */
  private fun shouldIncludeInVersion(arg: KotlinCompilerArgument, targetVersion: KotlinReleaseVersion): Boolean {
    val lifecycle = arg.releaseVersionsMetadata
    // Must be introduced by this version
    if (lifecycle.introducedVersion > targetVersion) return false
    // Must not be removed by this version
    lifecycle.removedVersion?.let { if (it <= targetVersion) return false }
    return true
  }

  /**
   * Check if a flag should be generated for a specific version.
   * Combines version filtering with allowlist/suppressed filtering.
   */
  private fun shouldGenerate(arg: KotlinCompilerArgument, targetVersion: KotlinReleaseVersion): Boolean {
    val flag = "-${arg.name}"
    return shouldIncludeInVersion(arg, targetVersion)
      && flag !in FlagPolicy.SUPPRESSED
      && flag in FlagPolicy.ALLOWLIST
  }

  /**
   * Parse enumerated values from valueDescription.
   * The format is typically {value1|value2|value3} or {value1/value2/value3}.
   * Returns null if the valueDescription doesn't contain enumerated values.
   */
  private fun parseEnumeratedValues(valueDescription: String?): List<String>? {
    if (valueDescription.isNullOrBlank()) return null

    // Match pattern like {value1|value2|value3} or {value1/value2/value3}
    val match = Regex("^\\{([^}]+)}$").find(valueDescription.trim()) ?: return null
    val content = match.groupValues[1]

    // Split by | or / and filter out placeholders like <path>, <N>, etc.
    val values = content.split(Regex("[|/]"))
      .map { it.trim() }
      .filter { it.isNotBlank() && !it.startsWith("<") && !it.endsWith(">") }

    return if (values.size >= 2) values else null
  }

  /**
   * Generate capabilities file name for a specific Kotlin version.
   */
  fun capabilitiesName(version: KotlinReleaseVersion): String =
    "capabilities_${version.major}.${version.minor}.bzl.com_github_jetbrains_kotlin.bazel"

  /**
   * Generate generated_opts file name for a specific Kotlin version.
   */
  fun generatedOptsName(version: KotlinReleaseVersion): String =
    "generated_opts_${version.major}.${version.minor}.bzl.com_github_jetbrains_kotlin.bazel"

  private class BzlDoc {
    private val header = Comment(BAZEL_HEADER)

    val contents: MutableList<Block> = mutableListOf()

    constructor(statements: BzlDoc.() -> Unit) {
      statement(header)
      apply(statements)
    }

    fun statement(vararg statements: Block) {
      contents.addAll(statements)
    }

    class Indent(val spaces: Int = 0) {
      fun increment() = Indent(spaces+2)
      fun decrement() = Indent(max(spaces - 2, 0))
      override fun toString() = " ".repeat(spaces)
      operator fun plus(s:String?) = toString() + s
    }

    fun interface Block {
      fun asString(indent: Indent): String?
      fun asString() = asString(Indent())
    }

    fun interface ValueBlock : Block {
      fun asString(indent: Indent, map: (String) -> String): String?
      override fun asString(indent: Indent) = asString(indent.increment()) { it }
    }

    class Comment(val contents: String) : Block {
      override fun asString(indent: Indent): String? = indent + contents
    }

    override fun toString() = contents.mapNotNull { it.asString() }.joinToString("\n")

    fun assignment(key: String, value: ValueBlock) {
      statement(
        Block { indent ->
          indent + value.asString(indent.increment()) { "$key = $it" }
        },
      )
    }

    fun struct(vararg properties: Pair<String, String?>) = ValueBlock { indent, format ->
      properties
        .mapNotNull { (key, value) ->
          value?.let { "$indent$key = $it" }
        }
        .joinToString(",\n", prefix = "struct(\n", postfix = "\n${indent.decrement()})")
        .run(format)
    }

    fun dict(vararg properties: Pair<String, ValueBlock>) = ValueBlock { indent, format ->
      properties
        .mapNotNull { (key, value) ->
          value.asString(indent.increment())
            ?.let { "$indent${key.bzlQuote()} : $it" }
        }
        .joinToString(",\n", prefix = "{\n", postfix = "\n${indent.decrement()}}")
        .run(format)
    }

    fun list(vararg items: String) = ValueBlock { indent, format ->
      items
        .joinToString(
            separator = ",\n",
            prefix = "[\n",
            postfix = "\n${indent.decrement()}]",
        ) { "$indent$it" }
        .run(format)
    }
  }

  /**
   * Extract compiler arguments from kotlin-compiler-arguments-description artifact.
   * This collects arguments from the path from topLevel to JVM arguments,
   * including common compiler arguments.
   */
  private fun getArgumentsFromDescription(): Sequence<KotlincCapability> = sequence {
    // Find the path from topLevel to jvmCompilerArguments
    val path = findPathToLevel(
      kotlinCompilerArguments.topLevel,
      CompilerArgumentsLevelNames.jvmCompilerArguments,
      mutableListOf()
    )
    if (path != null) {
      // Collect arguments from all levels in the path (common + JVM specific)
      for (level in path) {
        yieldAll(collectArgumentsFromLevel(level))
      }
    }
  }

  /**
   * Get all arguments including removed ones.
   * This is used for multi-version generation where we need to include
   * flags that existed in older versions but have been removed.
   */
  private fun getAllArguments(): Sequence<KotlinCompilerArgument> = sequence {
    // Active arguments from the path to JVM arguments
    val path = findPathToLevel(
      kotlinCompilerArguments.topLevel,
      CompilerArgumentsLevelNames.jvmCompilerArguments,
      mutableListOf()
    )
    if (path != null) {
      for (level in path) {
        yieldAll(level.arguments)
      }
    }

    // Removed arguments
    yieldAll(removedJvmCompilerArguments.arguments)
    yieldAll(removedCommonCompilerArguments.arguments)
  }

  /**
   * Find a path from the current level to the target level.
   * Returns a list of levels from root to target (inclusive), or null if not found.
   */
  private fun findPathToLevel(
    level: KotlinCompilerArgumentsLevel,
    targetName: String,
    currentPath: MutableList<KotlinCompilerArgumentsLevel>
  ): List<KotlinCompilerArgumentsLevel>? {
    currentPath.add(level)
    if (level.name == targetName) return currentPath.toList()
    for (subLevel in level.nestedLevels) {
      findPathToLevel(subLevel, targetName, currentPath)?.let { return it }
    }
    currentPath.removeLast()
    return null
  }

  /**
   * Collect all arguments from a single level.
   */
  private fun collectArgumentsFromLevel(level: KotlinCompilerArgumentsLevel): Sequence<KotlincCapability> = sequence {
    for (arg in level.arguments) {
      yield(arg.toCapability())
    }
  }

  /**
   * Convert a KotlinCompilerArgument to our KotlincCapability.
   */
  private fun KotlinCompilerArgument.toCapability(): KotlincCapability {
    val defaultValue: String? = when (val vt = valueType) {
      is BooleanType -> vt.defaultValue.current?.let { if (it) "true" else "false" }
      is StringType -> vt.defaultValue.current
      is StringArrayType -> vt.defaultValue.current?.joinToString(",")
      is IntType -> vt.defaultValue.current?.toString()
      else -> null
    }

    val starlarkType = when (valueType) {
      is BooleanType -> StarlarkType.Bool
      is StringType -> StarlarkType.Str
      is StringArrayType -> StarlarkType.StrList
      is IntType -> StarlarkType.Str // Int represented as string in Starlark
      else -> StarlarkType.Str
    }

    // Extract enumerated values from valueDescription if available
    val enumValues = parseEnumeratedValues(valueDescription.current)

    return KotlincCapability(
      flag = "-$name",
      doc = description.current,
      default = defaultValue,
      type = starlarkType,
      enumeratedValues = enumValues,
      introducedVersion = releaseVersionsMetadata.introducedVersion.toString(),
      stabilizedVersion = releaseVersionsMetadata.stabilizedVersion?.toString(),
    )
  }

  private class KotlincCapabilities(val capabilities: Iterable<KotlincCapability>) {

    companion object {
      fun Sequence<KotlincCapability>.asCapabilities() = KotlincCapabilities(sorted().toList())
      fun List<KotlincCapability>.asCapabilities() = KotlincCapabilities(sorted())
    }

    fun asCapabilitiesBzl() = BzlDoc {
      assignment(
        "KOTLIN_OPTS",
        dict(
          *capabilities.map { capability ->
            capability.flag to struct(
              "flag" to capability.flag.bzlQuote(),
              "doc" to capability.doc.bzlQuote(),
              "default" to capability.defaultStarlarkValue(),
              "introduced" to capability.introducedVersion?.bzlQuote(),
              "stabilized" to capability.stabilizedVersion?.bzlQuote(),
            )
          }.toTypedArray(),
        ),
      )
    }

    /**
     * Generate the full _KOPTS dict for opts.kotlinc.bzl.
     */
    fun asGeneratedOptsBzl(): String {
      val tq = "\"\"\""  // triple quote for Python docstrings
      val helperFunctions = """
def _map_string_flag(flag):
    ${tq}Create a mapper for string flags that passes value as flag=value.$tq
    def mapper(value):
        if not value:
            return None
        return [flag + "=" + value]
    return mapper

def _map_string_list_flag(flag):
    ${tq}Create a mapper for string list flags that passes each value as flag=value.$tq
    def mapper(values):
        if not values:
            return None
        return [flag + "=" + v for v in values]
    return mapper
"""
      val entries = capabilities.joinToString(",\n") { capability ->
        "    ${capability.starlarkAttrName().bzlQuote()}: ${capability.asOptStructString("    ")}"
      }
      return "$BAZEL_HEADER\n$helperFunctions\n\nGENERATED_KOPTS = {\n$entries\n}\n"
    }
  }

  data class KotlincCapability(
    val flag: String,
    val doc: String,
    private val default: String?,
    val type: StarlarkType,
    val enumeratedValues: List<String>? = null,
    val introducedVersion: String? = null,
    val stabilizedVersion: String? = null,
  ) : Comparable<KotlincCapability> {

    fun shouldSuppress() = flag in suppressedFlags

    fun defaultStarlarkValue(): String? = type.convert(default)

    /** Returns true if this option is considered experimental (not yet stabilized). */
    fun isExperimental(): Boolean = stabilizedVersion == null

    override fun compareTo(other: KotlincCapability): Int = flag.compareTo(other.flag)

    /**
     * Convert flag name to Starlark attribute name.
     * e.g., "-Xcontext-receivers" -> "x_context_receivers"
     *       "-java-parameters" -> "java_parameters"
     */
    fun starlarkAttrName(): String {
      return flag
        .removePrefix("-")
        .replace(Regex("^X"), "x_")  // -Xfoo -> x_foo (add underscore after x)
        .replace("-", "_")
        .lowercase()
    }

    /**
     * Generate the struct string for this option in _KOPTS format.
     * String options with enumerated values use the values list for analysis-time validation.
     */
    fun asOptStructString(indent: String): String {
      return when (type) {
        is StarlarkType.Bool -> buildOptStruct(
          attrType = "attr.bool",
          argsExtra = emptyMap(),
          valueToFlag = "{True: [\"$flag\"]}",
        )
        is StarlarkType.Str -> {
          val argsExtra = if (enumeratedValues != null) {
            val valuesStr = enumeratedValues.joinToString(", ") { "\"$it\"" }
            mapOf("values" to "[\"\",$valuesStr]")
          } else {
            mapOf("default" to (default?.bzlQuote() ?: "\"\""))
          }
          buildOptStruct(
            attrType = "attr.string",
            argsExtra = argsExtra,
            mapValueToFlag = "_map_string_flag(${flag.bzlQuote()})",
          )
        }
        is StarlarkType.StrList -> buildOptStruct(
          attrType = "attr.string_list",
          argsExtra = mapOf("default" to "[]"),
          mapValueToFlag = "_map_string_list_flag(${flag.bzlQuote()})",
        )
      }.prependIndent(indent)
    }

    private fun buildOptStruct(
      attrType: String,
      argsExtra: Map<String, String>,
      valueToFlag: String? = null,
      mapValueToFlag: String? = null,
    ): String {
      val argsEntries = buildList {
        add("doc = ${doc.bzlQuote()}")
        argsExtra.forEach { (key, value) -> add("$key = $value") }
      }.joinToString(",\n            ")

      return buildString {
        appendLine("struct(")
        appendLine("    flag = ${flag.bzlQuote()},")
        appendLine("    args = dict(")
        appendLine("        $argsEntries,")
        appendLine("    ),")
        appendLine("    type = $attrType,")
        if (valueToFlag != null) {
          appendLine("    value_to_flag = $valueToFlag,")
        } else {
          appendLine("    value_to_flag = None,")
          appendLine("    map_value_to_flag = $mapValueToFlag,")
        }
        append(")")
      }
    }
  }

  sealed class StarlarkType {
    abstract fun convert(value: String?): String

    data object Bool : StarlarkType() {
      override fun convert(value: String?): String = if (value == "true") "True" else "False"
    }

    data object Str : StarlarkType() {
      override fun convert(value: String?): String = value?.bzlQuote() ?: "None"
    }

    data object StrList : StarlarkType() {
      override fun convert(value: String?): String =
        value?.let { "default = [${it.bzlQuote()}]" } ?: "[]"
    }
  }

  private fun Any.bzlQuote(): String {
    var asString = toString()
    val quote = "\"".repeat(if ("\n" in asString || "\"" in asString) 3 else 1)
    return quote + asString + quote
  }
}

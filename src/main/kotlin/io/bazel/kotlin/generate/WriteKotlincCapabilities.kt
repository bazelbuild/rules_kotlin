package io.bazel.kotlin.generate

import io.bazel.kotlin.generate.WriteKotlincCapabilities.KotlincCapabilities.Companion.asCapabilities
import org.jetbrains.kotlin.arguments.description.CompilerArgumentsLevelNames
import org.jetbrains.kotlin.arguments.description.kotlinCompilerArguments
import org.jetbrains.kotlin.arguments.description.removed.removedCommonCompilerArguments
import org.jetbrains.kotlin.arguments.description.removed.removedJvmCompilerArguments
import org.jetbrains.kotlin.arguments.dsl.base.KotlinCompilerArgument
import org.jetbrains.kotlin.arguments.dsl.base.KotlinCompilerArgumentsLevel
import org.jetbrains.kotlin.arguments.dsl.base.KotlinReleaseVersion
import org.jetbrains.kotlin.arguments.dsl.types.BooleanType
import org.jetbrains.kotlin.arguments.dsl.types.IntType
import org.jetbrains.kotlin.arguments.dsl.types.JvmTarget
import org.jetbrains.kotlin.arguments.dsl.types.StringArrayType
import org.jetbrains.kotlin.arguments.dsl.types.StringType
import java.nio.charset.StandardCharsets
import java.nio.file.FileSystems
import java.nio.file.Files
import java.time.Year
import kotlin.io.path.exists
import kotlin.io.path.writeText
import kotlin.math.max
import kotlin.streams.toList

/**
 * Generates a list of kotlinc flags from the kotlin-compiler-arguments-description artifact.
 * This artifact provides structured metadata about all compiler options including:
 * - Flag name and description
 * - Type information (boolean, string, string list)
 * - Lifecycle information (introduced version, stabilized version, deprecated version)
 */
object WriteKotlincCapabilities {

  private val BAZEL_HEADER = """
    |# Copyright ${Year.now()} The Bazel Authors. All rights reserved.
    |#
    |# Licensed under the Apache License, Version 2.0 (the "License");
    |# you may not use this file except in compliance with the License.
    |# You may obtain a copy of the License at
    |#
    |#    http://www.apache.org/licenses/LICENSE-2.0
    |#
    |# Unless required by applicable law or agreed to in writing, software
    |# distributed under the License is distributed on an "AS IS" BASIS,
    |# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    |# See the License for the specific language governing permissions and
    |# limitations under the License.
    |
    |# DO NOT EDIT: generated by bazel run //src/main/kotlin/io/bazel/kotlin/generate:kotlin_release_options
  """.trimMargin()

  @JvmStatic
  fun main(vararg args: String) {
    val options = parseOptions(args)

    val envPattern = Regex("\\$\\{(\\w+)}")
    val capabilitiesDirectory = options["--out"]
      ?.first()
      ?.let { env ->
        envPattern.replace(env) {
          System.getenv(it.groups[1]?.value)
        }
      }
      ?.run(FileSystems.getDefault()::getPath)
      ?.apply {
        if (!parent.exists()) {
          Files.createDirectories(parent)
        }
      }
      ?: error("--out is required")

    // Get optional target version filter (for testing single versions)
    val targetVersionFilter = options["--target-version"]?.firstOrNull()

    // Get all arguments including removed ones for multi-version support
    val allArguments = getAllArguments().toList()

    // Determine which versions to generate
    val versionsToGenerate = if (targetVersionFilter != null) {
      val version = SUPPORTED_VERSIONS.find {
        "${it.major}.${it.minor}" == targetVersionFilter
      } ?: error("Unknown target version: $targetVersionFilter. Supported: ${SUPPORTED_VERSIONS.map { "${it.major}.${it.minor}" }}")
      listOf(version)
    } else {
      SUPPORTED_VERSIONS
    }

    // Generate files for each supported version
    for (targetVersion in versionsToGenerate) {
      val rawCapabilities = allArguments
        .filter { shouldGenerate(it, targetVersion) }
        .map { it.toCapability() }

      // Build set of flags present in this version for pair detection
      val flagsInVersion = rawCapabilities.map { it.flag }.toSet()

      // Mark experimental flags as deprecated when their stable counterpart exists
      val capabilities = rawCapabilities.map { capability ->
        val stableCounterpart = FlagPolicy.deriveStableCounterpart(capability.flag)
        if (stableCounterpart != null && stableCounterpart in flagsInVersion) {
          capability.copy(deprecatedInFavorOf = stableCounterpart)
        } else {
          capability
        }
      }.asCapabilities()

      // Generate opts file (only for Kotlin 2.0+)
      if (targetVersion >= KotlinReleaseVersion.v2_0_0) {
        capabilitiesDirectory.resolve(generatedOptsName(targetVersion)).writeText(
          capabilities.asGeneratedOptsBzl(targetVersion),
          StandardCharsets.UTF_8,
        )
      }

      println("Generated files for Kotlin ${targetVersion.major}.${targetVersion.minor}")
    }

    // Generate templates.bzl with generated_opts templates
    capabilitiesDirectory.resolve("templates.bzl").writeText(
      BzlDoc {
        assignment(
          "GENERATED_OPTS_TEMPLATES",
          list(*listTemplateFiles(capabilitiesDirectory, "generated_opts_")),
        )
      }.toString(),
    )
  }

  private fun listTemplateFiles(directory: java.nio.file.Path, prefix: String): Array<String> =
    Files.list(directory)
      .filter { it.fileName.toString().startsWith(prefix) }
      .map { "Label(${it.fileName.bzlQuote()})" }
      .sorted()
      .toList()
      .toTypedArray()

  private fun parseOptions(args: Array<out String>): Map<String, List<String>> =
    args.asSequence()
      .flatMap { it.split("=", limit = 2) }
      .chunked(2)
      .filter { it.size == 2 }
      .groupBy({ it[0] }, { it[1] })

  /**
   * Flag policy for allowlist-based generation with multi-version support.
   * Based on design doc: docs/design/kotlinc_options_multi_version.md
   */
  object FlagPolicy {
    /**
     * Derive the stable counterpart for an experimental flag, if applicable.
     * For flags like "-Xfoo-bar", returns "-foo-bar".
     * Returns null for non-experimental flags or flags that don't follow the -X pattern.
     */
    fun deriveStableCounterpart(experimentalFlag: String): String? {
      // Must start with -X (experimental prefix)
      if (!experimentalFlag.startsWith("-X")) return null
      // Derive stable form: -Xfoo -> -foo
      return "-" + experimentalFlag.removePrefix("-X")
    }

    /**
     * Derive the experimental counterpart for a stable flag, if applicable.
     * For flags like "-foo-bar", returns "-Xfoo-bar".
     */
    fun deriveExperimentalCounterpart(stableFlag: String): String? {
      // Must start with - but not -X
      if (!stableFlag.startsWith("-") || stableFlag.startsWith("-X")) return null
      // Derive experimental form: -foo -> -Xfoo
      return "-X" + stableFlag.removePrefix("-")
    }

    /**
     * Flags that must NEVER be exposed regardless of any other consideration.
     * These are managed by rules_kotlin, require path handling, or conflict with rules behavior.
     */
    val SUPPRESSED = setOf(
      // === Managed by rules_kotlin ===
      "-classpath",              // Set by compilation action
      "-d",                      // Output directory set by rules
      "-module-name",            // Set by rules from target name
      "-api-version",            // Set by toolchain/configuration
      "-language-version",       // Set by toolchain/configuration
      "-Xfriend-paths",          // Use `associates` attribute instead
      "-no-jdk",                 // JDK management is rules' job
      "-no-stdlib",              // Part of include_stdlibs abstraction
      "-no-reflect",             // Part of include_stdlibs abstraction

      // === Path-based flags (need action input handling) ===
      "-jdk-home",               // JDK managed by toolchain
      "-kotlin-home",            // Kotlin managed by rules
      "-Xplugin",                // Plugins via kt_compiler_plugin
      "-Xcompiler-plugin",       // Plugins via kt_compiler_plugin
      "-P",                      // Plugin options via kt_compiler_plugin
      "-Xklib",                  // Would need action inputs
      "-Xmodule-path",           // Java 9+ modules need explicit handling
      "-Xprofile",               // Would produce untracked outputs

      // === Java compilation (separate pipeline) ===
      "-Xjavac-arguments",       // Use kt_javac_options
      "-Xjava-source-roots",     // Java sources compiled separately
      "-Xcompile-java",          // Java via java builder
      "-Xuse-javac",             // Java via java builder
      "-Xjava-package-prefix",   // Java compilation separate

      // === Script compilation (not supported) ===
      "-script",
      "-script-templates",
      "-expression",
      "-Xdefault-script-extension",
      "-Xdisable-standard-script",
      "-Xscript-resolver-environment",
      "-Xallow-any-scripts-in-source-roots",
      "-Xdisable-default-scripting-plugin",

      // === Conflicts with rules_kotlin behavior ===
      "-Xno-reset-jar-timestamps",   // Rules explicitly zero timestamps
      "-Xoutput-builtins-metadata",  // Outputs not added to rule outputs
      "-Xallow-no-source-files",     // Rules validate sources exist

      // === Kapt and K2 (explicitly supported via rules) ===
      "-Xuse-k2-kapt",
      "-Xuse-k2",                   // K2 enabled via toolchain, not user option

      // === Fragment flags (complex multiplatform, hard to use correctly) ===
      "-Xfragments",
      "-Xfragment-sources",
      "-Xfragment-refines",
      "-Xfragment-dependency",
      "-Xfragment-friend-dependency",

      // === Internal/debugging (not useful for users) ===
      "-Xbuild-file",
      "-Xdump-declarations-to",
      "-Xdump-directory",
      "-Xdump-fqname",
      "-Xdump-perf",
      "-Xintellij-plugin-root",
      "-help",
      "-X",
      "-version",                // Just displays version
      "-Xrepl",                  // REPL mode

      // === Stdlib compilation (internal use only) ===
      "-Xstdlib-compilation",
      "-Xcompile-builtins-as-part-of-stdlib",

      // === Source file manipulation (not viable without rule support) ===
      "-Xcommon-sources",        // Adds source files to compilation

      // === Java 9+ modules (need action input handling) ===
      "-Xadd-modules",           // Module jars need to be action inputs

      // === Manually handled in opts.kotlinc.bzl ===
      "-Werror",                 // Part of `warn` abstraction
      "-nowarn",                 // Part of `warn` abstraction
      "-Xwarning-level",         // Dict type requires manual handling
    )

    /**
     * Flags approved for automatic generation. Only flags in this set AND not in SUPPRESSED
     * will be generated. Organized by category for easier review.
     */
    val ALLOWLIST: Set<String>
      get() = BOOLEAN_FLAGS + ENUM_FLAGS + STRING_FLAGS + STRING_LIST_FLAGS + INT_FLAGS

    /** Boolean flags (simple enable/disable) */
    private val BOOLEAN_FLAGS = setOf(
      // Nullability & Type Safety
      "-Xenhance-type-parameter-types-to-def-not-null",
      "-Xtype-enhancement-improvements-strict-mode",
      "-Xno-call-assertions",
      "-Xno-param-assertions",
      "-Xno-receiver-assertions",
      "-Xno-unified-null-checks",

      // Language Features
      "-Xcontext-receivers",
      "-Xcontext-parameters",
      "-Xinline-classes",
      "-Xvalue-classes",
      "-Xmulti-platform",
      "-Xexpect-actual-classes",
      "-Xexplicit-backing-fields",
      "-Xwhen-guards",
      "-Xnon-local-break-continue",
      "-Xnested-type-aliases",
      "-Xmulti-dollar-interpolation",
      "-Xannotation-target-all",
      "-Xdata-flow-based-exhaustiveness",
      "-Xallow-kotlin-package",
      "-Xconsistent-data-class-copy-visibility",
      "-Xcontext-sensitive-resolution",
      "-Xdirect-java-actualization",

      // Contracts
      "-Xallow-condition-implies-returns-contracts",
      "-Xallow-contracts-on-more-functions",
      "-Xallow-holdsin-contract",

      // Code Generation
      "-java-parameters",
      "-Xemit-jvm-type-annotations",
      "-Xmultifile-parts-inherit",
      "-Xno-new-java-annotation-targets",
      "-Xsanitize-parentheses",
      "-Xindy-allow-annotated-lambdas",
      "-Xjvm-enable-preview",
      "-Xjvm-expose-boxed",
      "-Xannotations-in-metadata",

      // Compilation Behavior
      "-progressive",
      "-verbose",
      "-Wextra",
      "-Xno-inline",
      "-Xno-optimize",
      "-Xskip-metadata-version-check",
      "-Xskip-prerelease-check",
      "-Xallow-unstable-dependencies",
      "-Xgenerate-strict-metadata-version",
      "-Xreport-all-warnings",
      "-Xdont-warn-on-error-suppression",
      "-Xsuppress-version-warnings",
      "-Xsuppress-deprecated-jvm-target-warning",
      "-Xsuppress-missing-builtins-error",
      "-Xsuppress-api-version-greater-than-language-version-error",
      "-Xrender-internal-diagnostic-names",
      "-Xignore-const-optimization-errors",
      "-Xunrestricted-builder-inference",

      // IR & Backend
      "-Xnew-inference",
      "-Xir-inliner",
      "-Xir-do-not-clear-binding-context",
      "-Xuse-fast-jar-file-system",
      "-Xuse-fir-ic",
      "-Xuse-fir-lt",
      "-Xuse-fir-experimental-checkers",
      "-Xuse-inline-scopes-numbers",
      "-Xuse-type-table",
      "-Xuse-14-inline-classes-mangling-scheme",
      "-Xlink-via-signatures",
      "-Xvalidate-bytecode",
      "-Xuse-old-class-files-reading",
      "-Xmetadata-klib",
      "-Xenhanced-coroutines-debugging",

      // Debugging & Profiling
      "-Xdebug",
      "-Xcheck-phase-conditions",
      "-Xlist-phases",
      "-Xprofile-phases",
      "-Xreport-perf",
      "-Xdetailed-perf",
      "-Xreport-output-files",
      "-Xverify-ir-visibility",

      // Multiplatform
      "-Xno-check-actual",
      "-Xseparate-kmp-compilation",

      // Experimental/Advanced
      "-Xenable-incremental-compilation",
      "-XXlenient-mode",
      "-XXdebug-level-compiler-checks",
      "-Xallow-reified-type-in-catch",
    )

    /** Enum flags (with restricted values extracted from valueDescription) */
    private val ENUM_FLAGS = setOf(
      // Nullability handling
      "-Xjspecify-annotations",

      // Code generation schemes
      "-Xlambdas",
      "-Xsam-conversions",
      "-Xstring-concat",
      "-Xwhen-expressions",

      // JVM default methods
      "-jvm-default",
      "-Xjvm-default",  // Deprecated but still present

      // Assertions
      "-Xassertions",

      // API visibility
      "-Xexplicit-api",
      "-XXexplicit-return-types",

      // IR
      "-Xserialize-ir",
      "-Xverify-ir",
      "-Xabi-stability",

      // Return value checker
      "-Xreturn-value-checker",

      // Destructuring
      "-Xname-based-destructuring",

      // Annotation targets
      "-Xannotation-default-target",
    )

    /** String flags (free-form values) */
    private val STRING_FLAGS = setOf(
      "-jvm-target",
      "-Xjdk-release",
      "-Xmetadata-version",
      "-Xsupport-compatqual-checker-framework-annotations",
      "-XXdump-model",
    )

    /** String list flags (multiple free-form values) */
    private val STRING_LIST_FLAGS = setOf(
      "-opt-in",
      "-Xjsr305",
      "-Xnullability-annotations",
      "-Xsuppress-warning",
      "-Xcompiler-plugin-order",
      "-XXLanguage",

      // Phase manipulation (debugging)
      "-Xdisable-phases",
      "-Xphases-to-dump",
      "-Xphases-to-dump-before",
      "-Xphases-to-dump-after",
      "-Xphases-to-validate",
      "-Xphases-to-validate-before",
      "-Xphases-to-validate-after",
      "-Xverbose-phases",
    )

    /** Int flags */
    private val INT_FLAGS = setOf(
      "-Xbackend-threads",
    )
  }

  /**
   * Supported Kotlin versions for multi-version generation.
   * We generate separate generated_opts files for each version.
   * Only Kotlin 2.0+ is supported.
   */
  val SUPPORTED_VERSIONS = listOf(
    KotlinReleaseVersion.v2_0_0,
    KotlinReleaseVersion.v2_1_0,
    KotlinReleaseVersion.v2_2_0,
    KotlinReleaseVersion.v2_3_0,
  )

  /**
   * Get valid JVM target versions for a specific Kotlin release version.
   * Uses lifecycle metadata from JvmTarget enum to determine which targets are available.
   */
  fun getValidJvmTargets(targetVersion: KotlinReleaseVersion): List<String> {
    return JvmTarget.entries
      .filter { jvmTarget ->
        val lifecycle = jvmTarget.releaseVersionsMetadata
        // Must be introduced by this version
        lifecycle.introducedVersion <= targetVersion &&
          // Must not be removed by this version
          (lifecycle.removedVersion == null || lifecycle.removedVersion!! > targetVersion)
      }
      .map { it.targetName }
  }

  /**
   * Check if a flag should be included in the generated files for a target version.
   * A flag is included if:
   * - It was introduced by or before the target version
   * - It has not been removed, or was removed after the target version
   */
  private fun shouldIncludeInVersion(arg: KotlinCompilerArgument, targetVersion: KotlinReleaseVersion): Boolean {
    val lifecycle = arg.releaseVersionsMetadata
    // Must be introduced by this version
    if (lifecycle.introducedVersion > targetVersion) return false
    // Must not be removed by this version
    lifecycle.removedVersion?.let { if (it <= targetVersion) return false }
    return true
  }

  /**
   * Check if a flag should be generated for a specific version.
   * Combines version filtering with allowlist/suppressed filtering.
   */
  private fun shouldGenerate(arg: KotlinCompilerArgument, targetVersion: KotlinReleaseVersion): Boolean {
    val flag = "-${arg.name}"
    return shouldIncludeInVersion(arg, targetVersion)
      && flag !in FlagPolicy.SUPPRESSED
      && flag in FlagPolicy.ALLOWLIST
  }

  /**
   * Parse enumerated values from valueDescription/description metadata.
   *
   * Supports:
   * - inline sets like `{foo|bar|baz}`
   * - prose snippets like `-Xfoo=bar`
   */
  private fun parseEnumeratedValues(
    flag: String,
    valueDescription: String?,
    description: String,
  ): List<String>? {
    val values = linkedSetOf<String>()
    val sources = listOfNotNull(valueDescription, description)

    val bracePattern = Regex("\\{([^{}]+)}")
    val assignmentPattern = Regex("${Regex.escape(flag)}=([A-Za-z0-9][A-Za-z0-9-]*)")

    for (source in sources) {
      bracePattern.findAll(source).forEach { match ->
        match.groupValues[1]
          .split(Regex("[|/]"))
          .map(String::trim)
          .filter(::isEnumValueToken)
          .forEach(values::add)
      }

      assignmentPattern.findAll(source).forEach { match ->
        val candidate = match.groupValues[1].trim()
        if (isEnumValueToken(candidate)) {
          values.add(candidate)
        }
      }
    }

    // Fallback for value descriptions that are plain disjunctions like "ignore|strict|warn".
    if (values.size < 2 && !valueDescription.isNullOrBlank()) {
      val directValues = valueDescription.trim()
        .removePrefix("{")
        .removeSuffix("}")
        .split(Regex("[|/]"))
        .map { it.trim().trim('"', '\'') }
        .filter(::isEnumValueToken)
      values.addAll(directValues)
    }

    return values.takeIf { it.size >= 2 }?.toList()
  }

  private fun isEnumValueToken(value: String): Boolean =
    value.isNotBlank() &&
      !value.startsWith("<") &&
      !value.endsWith(">") &&
      Regex("^[A-Za-z0-9][A-Za-z0-9-]*$").matches(value)

  /**
   * Generate generated_opts file name for a specific Kotlin version.
   */
  fun generatedOptsName(version: KotlinReleaseVersion): String =
    "generated_opts_${version.major}.${version.minor}.bzl.com_github_jetbrains_kotlin.bazel"

  private class BzlDoc {
    private val header = Comment(BAZEL_HEADER)

    val contents: MutableList<Block> = mutableListOf()

    constructor(statements: BzlDoc.() -> Unit) {
      statement(header)
      apply(statements)
    }

    fun statement(vararg statements: Block) {
      contents.addAll(statements)
    }

    class Indent(val spaces: Int = 0) {
      fun increment() = Indent(spaces+2)
      fun decrement() = Indent(max(spaces - 2, 0))
      override fun toString() = " ".repeat(spaces)
      operator fun plus(s:String?) = toString() + s
    }

    fun interface Block {
      fun asString(indent: Indent): String?
      fun asString() = asString(Indent())
    }

    fun interface ValueBlock : Block {
      fun asString(indent: Indent, map: (String) -> String): String?
      override fun asString(indent: Indent) = asString(indent.increment()) { it }
    }

    class Comment(val contents: String) : Block {
      override fun asString(indent: Indent): String? = indent + contents
    }

    override fun toString() = contents.mapNotNull { it.asString() }.joinToString("\n")

    fun assignment(key: String, value: ValueBlock) {
      statement(
        Block { indent ->
          indent + value.asString(indent.increment()) { "$key = $it" }
        },
      )
    }

    fun struct(vararg properties: Pair<String, String?>) = ValueBlock { indent, format ->
      properties
        .mapNotNull { (key, value) ->
          value?.let { "$indent$key = $it" }
        }
        .joinToString(",\n", prefix = "struct(\n", postfix = "\n${indent.decrement()})")
        .run(format)
    }

    fun dict(vararg properties: Pair<String, ValueBlock>) = ValueBlock { indent, format ->
      properties
        .mapNotNull { (key, value) ->
          value.asString(indent.increment())
            ?.let { "$indent${key.bzlQuote()} : $it" }
        }
        .joinToString(",\n", prefix = "{\n", postfix = "\n${indent.decrement()}}")
        .run(format)
    }

    fun list(vararg items: String) = ValueBlock { indent, format ->
      items
        .joinToString(
            separator = ",\n",
            prefix = "[\n",
            postfix = "\n${indent.decrement()}]",
        ) { "$indent$it" }
        .run(format)
    }
  }

  /**
   * Get all arguments used by generation with deterministic deduplication.
   *
   * Priority:
   * 1) Active arguments in the path to JVM arguments (deeper levels override parents)
   * 2) Removed arguments only when missing from active metadata
   */
  private fun getAllArguments(): Sequence<KotlinCompilerArgument> {
    val byName = linkedMapOf<String, KotlinCompilerArgument>()

    val path = findPathToLevel(
      kotlinCompilerArguments.topLevel,
      CompilerArgumentsLevelNames.jvmCompilerArguments,
      mutableListOf(),
    )
    if (path != null) {
      for (level in path) {
        for (argument in level.arguments) {
          byName[argument.name] = argument
        }
      }
    }

    fun addRemovedIfMissing(arguments: Iterable<KotlinCompilerArgument>) {
      for (argument in arguments) {
        byName.putIfAbsent(argument.name, argument)
      }
    }

    addRemovedIfMissing(removedJvmCompilerArguments.arguments)
    addRemovedIfMissing(removedCommonCompilerArguments.arguments)

    return byName.values.asSequence()
  }

  /**
   * Find a path from the current level to the target level.
   * Returns a list of levels from root to target (inclusive), or null if not found.
   */
  private fun findPathToLevel(
    level: KotlinCompilerArgumentsLevel,
    targetName: String,
    currentPath: MutableList<KotlinCompilerArgumentsLevel>
  ): List<KotlinCompilerArgumentsLevel>? {
    currentPath.add(level)
    if (level.name == targetName) return currentPath.toList()
    for (subLevel in level.nestedLevels) {
      findPathToLevel(subLevel, targetName, currentPath)?.let { return it }
    }
    currentPath.removeLast()
    return null
  }

  /**
   * Convert a KotlinCompilerArgument to our KotlincCapability.
   */
  private fun KotlinCompilerArgument.toCapability(): KotlincCapability {
    val defaultValue: String? = when (val vt = valueType) {
      is BooleanType -> vt.defaultValue.current?.let { if (it) "true" else "false" }
      is StringType -> vt.defaultValue.current
      is StringArrayType -> vt.defaultValue.current?.joinToString(",")
      is IntType -> vt.defaultValue.current?.toString()
      else -> null
    }

    val starlarkType = when (valueType) {
      is BooleanType -> StarlarkType.Bool
      is StringType -> StarlarkType.Str
      is StringArrayType -> StarlarkType.StrList
      is IntType -> StarlarkType.Int
      else -> StarlarkType.Str
    }

    val flag = "-$name"

    val enumValues = parseEnumeratedValues(
      flag = flag,
      valueDescription = valueDescription.current,
      description = description.current,
    )

    return KotlincCapability(
      flag = flag,
      doc = description.current,
      default = defaultValue,
      type = starlarkType,
      enumeratedValues = enumValues,
      introducedVersion = releaseVersionsMetadata.introducedVersion.toString(),
      stabilizedVersion = releaseVersionsMetadata.stabilizedVersion?.toString(),
    )
  }

  private class KotlincCapabilities(val capabilities: Iterable<KotlincCapability>) {

    companion object {
      fun Sequence<KotlincCapability>.asCapabilities() = KotlincCapabilities(sorted().toList())
      fun List<KotlincCapability>.asCapabilities() = KotlincCapabilities(sorted())
    }

    /**
     * Generate the full _KOPTS dict for opts.kotlinc.bzl.
     */
    fun asGeneratedOptsBzl(targetVersion: KotlinReleaseVersion): String {
      val tq = "\"\"\""  // triple quote for Python docstrings
      val helperFunctions = """
def _map_string_flag(flag):
    ${tq}Create a mapper for string flags that passes value as flag=value.$tq
    def mapper(value):
        if not value:
            return None
        return [flag + "=" + value]
    return mapper

def _map_string_list_flag(flag):
    ${tq}Create a mapper for string list flags that passes each value as flag=value.$tq
    def mapper(values):
        if not values:
            return None
        return [flag + "=" + v for v in values]
    return mapper

def _map_int_flag(flag):
    ${tq}Create a mapper for int flags that passes value as flag=value.$tq
    def mapper(value):
        if not value:
            return None
        return [flag + "=" + str(value)]
    return mapper

def _map_warning_level(values):
    ${tq}Map warning level dict to -Xwarning-level flags.$tq
    if not values:
        return None
    _ALLOWED_LEVELS = ["error", "warning", "disabled"]
    args = []
    for k, v in values.items():
        if v not in _ALLOWED_LEVELS:
            fail("Error: Suppress key '{}' has an invalid value of '{}'. Allowed: {}".format(k, v, _ALLOWED_LEVELS))
        args.append("-Xwarning-level={}:{}".format(k, v))
    return args
"""
      // Get valid JVM targets for this Kotlin version
      val validJvmTargets = getValidJvmTargets(targetVersion)

      val entries = capabilities.joinToString(",\n") { capability ->
        // Override enumerated values for jvm_target and x_jdk_release with version-specific values
        val effectiveCapability = when (capability.flag) {
          "-jvm-target", "-Xjdk-release" -> capability.copy(enumeratedValues = validJvmTargets)
          else -> capability
        }
        "    ${effectiveCapability.starlarkAttrName().bzlQuote()}: ${effectiveCapability.asOptStructString("    ")}"
      }

      // Add custom rules_kotlin options that don't map directly to kotlinc flags
      val customOptions = """
    # === Custom rules_kotlin options (not direct kotlinc flags) ===
    "include_stdlibs": struct(
        args = dict(
            default = "all",
            doc = "Don't automatically include the Kotlin standard libraries into the classpath (stdlib and reflect).",
            values = ["all", "stdlib", "none"],
        ),
        type = attr.string,
        value_to_flag = {
            "all": None,
            "none": ["-no-stdlib"],
            "stdlib": ["-no-reflect"],
        },
    ),
    "warn": struct(
        args = dict(
            default = "report",
            doc = "Control warning behaviour.",
            values = ["off", "report", "error"],
        ),
        type = attr.string,
        value_to_flag = {
            "error": ["-Werror"],
            "off": ["-nowarn"],
            "report": None,
        },
    ),
    "x_warning_level": struct(
        args = dict(
            default = {},
            doc = "Suppress specific warnings globally. Ex: 'OPTION': '(error|warning|disabled)'",
        ),
        type = attr.string_dict,
        value_to_flag = None,
        map_value_to_flag = _map_warning_level,
    ),"""

      return "$BAZEL_HEADER\n$helperFunctions\n\nGENERATED_KOPTS = {\n$entries,\n$customOptions\n}\n"
    }
  }

  data class KotlincCapability(
    val flag: String,
    val doc: String,
    private val default: String?,
    val type: StarlarkType,
    val enumeratedValues: List<String>? = null,
    val introducedVersion: String? = null,
    val stabilizedVersion: String? = null,
    /** If this experimental flag has been superseded by a stable version, reference it here. */
    val deprecatedInFavorOf: String? = null,
  ) : Comparable<KotlincCapability> {

    fun defaultStarlarkValue(): String? = type.convert(default)

    /**
     * Get the documentation string, including deprecation notice if applicable.
     */
    fun effectiveDoc(): String {
      return if (deprecatedInFavorOf != null) {
        "DEPRECATED: Use $deprecatedInFavorOf instead.\n\n$doc"
      } else {
        doc
      }
    }

    override fun compareTo(other: KotlincCapability): Int = flag.compareTo(other.flag)

    /**
     * Convert flag name to Starlark attribute name.
     * e.g., "-Xcontext-receivers" -> "x_context_receivers"
     *       "-java-parameters" -> "java_parameters"
     */
    fun starlarkAttrName(): String {
      return flag
        .removePrefix("-")
        .replace(Regex("^X"), "x_")  // -Xfoo -> x_foo (add underscore after x)
        .replace("-", "_")
        .lowercase()
    }

    /**
     * Generate the struct string for this option in _KOPTS format.
     * String options with enumerated values use the values list for analysis-time validation.
     */
    fun asOptStructString(indent: String): String {
      return when (type) {
        is StarlarkType.Bool -> buildOptStruct(
          attrType = "attr.bool",
          argsExtra = emptyMap(),
          valueToFlag = "{True: [\"$flag\"]}",
        )
        is StarlarkType.Str -> {
          val argsExtra = if (enumeratedValues != null) {
            val valuesStr = enumeratedValues.joinToString(", ") { "\"$it\"" }
            mapOf("values" to "[\"\",$valuesStr]")
          } else {
            mapOf("default" to (default?.bzlQuote() ?: "\"\""))
          }
          buildOptStruct(
            attrType = "attr.string",
            argsExtra = argsExtra,
            mapValueToFlag = "_map_string_flag(${flag.bzlQuote()})",
          )
        }
        is StarlarkType.StrList -> buildOptStruct(
          attrType = "attr.string_list",
          argsExtra = mapOf("default" to "[]"),
          mapValueToFlag = "_map_string_list_flag(${flag.bzlQuote()})",
        )
        is StarlarkType.Int -> buildOptStruct(
          attrType = "attr.int",
          argsExtra = mapOf("default" to (default ?: "0")),
          mapValueToFlag = "_map_int_flag(${flag.bzlQuote()})",
        )
      }.prependIndent(indent)
    }

    private fun buildOptStruct(
      attrType: String,
      argsExtra: Map<String, String>,
      valueToFlag: String? = null,
      mapValueToFlag: String? = null,
    ): String {
      val argsEntries = buildList {
        add("doc = ${effectiveDoc().bzlQuote()}")
        argsExtra.forEach { (key, value) -> add("$key = $value") }
      }.joinToString(",\n            ")

      return buildString {
        appendLine("struct(")
        appendLine("    flag = ${flag.bzlQuote()},")
        appendLine("    args = dict(")
        appendLine("        $argsEntries,")
        appendLine("    ),")
        appendLine("    type = $attrType,")
        if (valueToFlag != null) {
          appendLine("    value_to_flag = $valueToFlag,")
        } else {
          appendLine("    value_to_flag = None,")
          appendLine("    map_value_to_flag = $mapValueToFlag,")
        }
        append(")")
      }
    }
  }

  sealed class StarlarkType {
    abstract fun convert(value: String?): String

    data object Bool : StarlarkType() {
      override fun convert(value: String?): String = if (value == "true") "True" else "False"
    }

    data object Str : StarlarkType() {
      override fun convert(value: String?): String = value?.bzlQuote() ?: "None"
    }

    data object StrList : StarlarkType() {
      override fun convert(value: String?): String =
        value?.let { "default = [${it.bzlQuote()}]" } ?: "[]"
    }

    data object Int : StarlarkType() {
      override fun convert(value: String?): String = value ?: "0"
    }
  }

  private fun Any.bzlQuote(): String {
    var asString = toString()
    val quote = "\"".repeat(if ("\n" in asString || "\"" in asString) 3 else 1)
    return quote + asString + quote
  }
}

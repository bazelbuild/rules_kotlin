# Copyright 2026 The Bazel Authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# DO NOT EDIT: generated by bazel run //src/main/kotlin/io/bazel/kotlin/generate:kotlin_release_options

def _map_string_flag(flag):
    """Create a mapper for string flags that passes value as flag=value."""
    def mapper(value):
        if not value:
            return None
        return [flag + "=" + value]
    return mapper

def _map_string_list_flag(flag):
    """Create a mapper for string list flags that passes each value as flag=value."""
    def mapper(values):
        if not values:
            return None
        return [flag + "=" + v for v in values]
    return mapper


GENERATED_KOPTS = {
    "x_xlanguage":     struct(
        flag = "-XXLanguage",
        args = dict(
            doc = """Enables/disables specified language feature.
    Warning: this flag is not intended for production use. If you want to configure the language behaviour use the
    -language-version or corresponding experimental feature flags.""",
                default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-XXLanguage"),
    ),
    "x_xdump_model":     struct(
        flag = "-XXdump-model",
        args = dict(
            doc = "Dump compilation model to specified directory for use in modularized tests.",
                default = "",
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-XXdump-model"),
    ),
    "x_abi_stability":     struct(
        flag = "-Xabi-stability",
        args = dict(
            doc = """When using unstable compiler features such as FIR, use 'stable' to mark generated class files as stable
    to prevent diagnostics from being reported when using stable compilers at the call site.
    When using the JVM IR backend, conversely, use 'unstable' to mark generated class files as unstable
    to force diagnostics to be reported.""",
                values = ["","stable", "unstable"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xabi-stability"),
    ),
    "x_allow_kotlin_package":     struct(
        flag = "-Xallow-kotlin-package",
        args = dict(
            doc = "Allow compiling code in the 'kotlin' package, and allow not requiring 'kotlin.stdlib' in 'module-info'.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xallow-kotlin-package"]},
    ),
    "x_allow_unstable_dependencies":     struct(
        flag = "-Xallow-unstable-dependencies",
        args = dict(
            doc = "Do not report errors on classes in dependencies that were compiled by an unstable version of the Kotlin compiler.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xallow-unstable-dependencies"]},
    ),
    "x_assertions":     struct(
        flag = "-Xassertions",
        args = dict(
            doc = """'kotlin.assert' call behavior:
    -Xassertions=always-enable:  enable, ignore JVM assertion settings;
    -Xassertions=always-disable: disable, ignore JVM assertion settings;
    -Xassertions=jvm:            enable, depend on JVM assertion settings;
    -Xassertions=legacy:         calculate the condition on each call, the behavior depends on JVM assertion settings in the kotlin package;
    default: legacy""",
                values = ["","always-enable", "always-disable", "jvm", "legacy"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xassertions"),
    ),
    "x_check_phase_conditions":     struct(
        flag = "-Xcheck-phase-conditions",
        args = dict(
            doc = "Check pre- and postconditions of IR lowering phases.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xcheck-phase-conditions"]},
    ),
    "x_context_receivers":     struct(
        flag = "-Xcontext-receivers",
        args = dict(
            doc = "Enable experimental context receivers.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xcontext-receivers"]},
    ),
    "x_debug":     struct(
        flag = "-Xdebug",
        args = dict(
            doc = """Enable debug mode for compilation.
    Currently this includes spilling all variables in a suspending context regardless of whether they are alive.
    If API Level >= 2.2 -- no-op.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xdebug"]},
    ),
    "x_disable_phases":     struct(
        flag = "-Xdisable-phases",
        args = dict(
            doc = "Disable backend phases.",
                default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-Xdisable-phases"),
    ),
    "x_dont_warn_on_error_suppression":     struct(
        flag = "-Xdont-warn-on-error-suppression",
        args = dict(
            doc = "Don't report warnings when errors are suppressed. This only affects K2.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xdont-warn-on-error-suppression"]},
    ),
    "x_emit_jvm_type_annotations":     struct(
        flag = "-Xemit-jvm-type-annotations",
        args = dict(
            doc = "Emit JVM type annotations in bytecode.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xemit-jvm-type-annotations"]},
    ),
    "x_enable_incremental_compilation":     struct(
        flag = "-Xenable-incremental-compilation",
        args = dict(
            doc = "Enable incremental compilation.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xenable-incremental-compilation"]},
    ),
    "x_enhance_type_parameter_types_to_def_not_null":     struct(
        flag = "-Xenhance-type-parameter-types-to-def-not-null",
        args = dict(
            doc = "Enhance not-null-annotated type parameter types to definitely-non-nullable types ('@NotNull T' => 'T & Any').",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xenhance-type-parameter-types-to-def-not-null"]},
    ),
    "x_expect_actual_classes":     struct(
        flag = "-Xexpect-actual-classes",
        args = dict(
            doc = """'expect'/'actual' classes (including interfaces, objects, annotations, enums, and 'actual' typealiases) are in Beta.
    Kotlin reports a warning every time you use one of them. You can use this flag to mute the warning.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xexpect-actual-classes"]},
    ),
    "x_explicit_api":     struct(
        flag = "-Xexplicit-api",
        args = dict(
            doc = """Force the compiler to report errors on all public API declarations without an explicit visibility or a return type.
    Use the 'warning' level to issue warnings instead of errors.""",
                values = ["","strict", "warning", "disable"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xexplicit-api"),
    ),
    "x_generate_strict_metadata_version":     struct(
        flag = "-Xgenerate-strict-metadata-version",
        args = dict(
            doc = "Generate metadata with strict version semantics (see the KDoc entry on 'Metadata.extraInt').",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xgenerate-strict-metadata-version"]},
    ),
    "x_ignore_const_optimization_errors":     struct(
        flag = "-Xignore-const-optimization-errors",
        args = dict(
            doc = "Ignore all compilation exceptions while optimizing some constant expressions.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xignore-const-optimization-errors"]},
    ),
    "x_inline_classes":     struct(
        flag = "-Xinline-classes",
        args = dict(
            doc = "Enable experimental inline classes.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xinline-classes"]},
    ),
    "x_ir_do_not_clear_binding_context":     struct(
        flag = "-Xir-do-not-clear-binding-context",
        args = dict(
            doc = "When using the IR backend, do not clear BindingContext between 'psi2ir' and lowerings.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xir-do-not-clear-binding-context"]},
    ),
    "x_ir_inliner":     struct(
        flag = "-Xir-inliner",
        args = dict(
            doc = "Inline functions using the IR inliner instead of the bytecode inliner.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xir-inliner"]},
    ),
    "x_ir_inliner":     struct(
        flag = "-Xir-inliner",
        args = dict(
            doc = "Inline functions using the IR inliner instead of the bytecode inliner.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xir-inliner"]},
    ),
    "x_jspecify_annotations":     struct(
        flag = "-Xjspecify-annotations",
        args = dict(
            doc = """Specify the behavior of 'jspecify' annotations.
    The default value is 'strict'.""",
                default = "",
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xjspecify-annotations"),
    ),
    "x_jsr305":     struct(
        flag = "-Xjsr305",
        args = dict(
            doc = """Specify the behavior of 'JSR-305' nullability annotations:
    -Xjsr305={ignore/strict/warn}                   global (all non-@UnderMigration annotations)
    -Xjsr305=under-migration:{ignore/strict/warn}   all @UnderMigration annotations
    -Xjsr305=@<fq.name>:{ignore/strict/warn}        annotation with the given fully qualified class name
    Modes:
    * ignore
    * strict (experimental; treat like other supported nullability annotations)
    * warn (report a warning)""",
                default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-Xjsr305"),
    ),
    "x_jvm_default":     struct(
        flag = "-Xjvm-default",
        args = dict(
            doc = """This option is deprecated. Migrate to -jvm-default as follows:
    -Xjvm-default=disable            -> -jvm-default=disable
    -Xjvm-default=all-compatibility  -> -jvm-default=enable
    -Xjvm-default=all                -> -jvm-default=no-compatibility""",
                values = ["","all", "all-compatibility", "disable"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xjvm-default"),
    ),
    "x_jvm_enable_preview":     struct(
        flag = "-Xjvm-enable-preview",
        args = dict(
            doc = """Allow using Java features that are in the preview phase.
    This works like '--enable-preview' in Java. All class files are marked as compiled with preview features, meaning it won't be possible to use them in release environments.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xjvm-enable-preview"]},
    ),
    "x_lambdas":     struct(
        flag = "-Xlambdas",
        args = dict(
            doc = """Select the code generation scheme for lambdas.
    -Xlambdas=indy                  Generate lambdas using 'invokedynamic' with 'LambdaMetafactory.metafactory'.
                                    A lambda object created using 'LambdaMetafactory.metafactory' will have a different 'toString()'.
    -Xlambdas=class                 Generate lambdas as explicit classes.
    The default value is 'indy' if language version is 2.0+, and 'class' otherwise.""",
                values = ["","class", "indy"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xlambdas"),
    ),
    "x_link_via_signatures":     struct(
        flag = "-Xlink-via-signatures",
        args = dict(
            doc = """Link JVM IR symbols via signatures instead of descriptors.
    This mode is slower, but it can be useful for troubleshooting problems with the JVM IR backend.
    This option is deprecated and will be deleted in future versions.
    It has no effect when -language-version is 2.0 or higher.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xlink-via-signatures"]},
    ),
    "x_list_phases":     struct(
        flag = "-Xlist-phases",
        args = dict(
            doc = "List backend phases.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xlist-phases"]},
    ),
    "x_metadata_klib":     struct(
        flag = "-Xmetadata-klib",
        args = dict(
            doc = "Produce a klib that only contains the metadata of declarations.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xmetadata-klib"]},
    ),
    "x_metadata_version":     struct(
        flag = "-Xmetadata-version",
        args = dict(
            doc = "Change the metadata version of the generated binary files.",
                default = "",
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xmetadata-version"),
    ),
    "x_multi_platform":     struct(
        flag = "-Xmulti-platform",
        args = dict(
            doc = "Enable language support for multiplatform projects.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xmulti-platform"]},
    ),
    "x_multifile_parts_inherit":     struct(
        flag = "-Xmultifile-parts-inherit",
        args = dict(
            doc = "Compile multifile classes as a hierarchy of parts and a facade.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xmultifile-parts-inherit"]},
    ),
    "x_new_inference":     struct(
        flag = "-Xnew-inference",
        args = dict(
            doc = "Enable the new experimental generic type inference algorithm.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xnew-inference"]},
    ),
    "x_no_call_assertions":     struct(
        flag = "-Xno-call-assertions",
        args = dict(
            doc = "Don't generate not-null assertions for arguments of platform types.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-call-assertions"]},
    ),
    "x_no_check_actual":     struct(
        flag = "-Xno-check-actual",
        args = dict(
            doc = "Do not check for the presence of the 'actual' modifier in multiplatform projects.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-check-actual"]},
    ),
    "x_no_inline":     struct(
        flag = "-Xno-inline",
        args = dict(
            doc = "Disable method inlining.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-inline"]},
    ),
    "x_no_new_java_annotation_targets":     struct(
        flag = "-Xno-new-java-annotation-targets",
        args = dict(
            doc = "Don't generate Java 1.8+ targets for Kotlin annotation classes.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-new-java-annotation-targets"]},
    ),
    "x_no_optimize":     struct(
        flag = "-Xno-optimize",
        args = dict(
            doc = "Disable optimizations.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-optimize"]},
    ),
    "x_no_param_assertions":     struct(
        flag = "-Xno-param-assertions",
        args = dict(
            doc = "Don't generate not-null assertions on parameters of methods accessible from Java.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-param-assertions"]},
    ),
    "x_no_receiver_assertions":     struct(
        flag = "-Xno-receiver-assertions",
        args = dict(
            doc = "Don't generate not-null assertions for extension receiver arguments of platform types.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-receiver-assertions"]},
    ),
    "x_no_unified_null_checks":     struct(
        flag = "-Xno-unified-null-checks",
        args = dict(
            doc = "Use pre-1.4 exception types instead of 'java.lang.NPE' in null checks. See KT-22275 for more details.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-unified-null-checks"]},
    ),
    "x_nullability_annotations":     struct(
        flag = "-Xnullability-annotations",
        args = dict(
            doc = """Specify the behavior for specific Java nullability annotations (provided with fully qualified package name).
    Modes:
    * ignore
    * strict
    * warn (report a warning)""",
                default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-Xnullability-annotations"),
    ),
    "x_phases_to_dump":     struct(
        flag = "-Xphases-to-dump",
        args = dict(
            doc = "Dump the backend's state both before and after these phases.",
                default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-Xphases-to-dump"),
    ),
    "x_phases_to_dump_after":     struct(
        flag = "-Xphases-to-dump-after",
        args = dict(
            doc = "Dump the backend's state after these phases.",
                default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-Xphases-to-dump-after"),
    ),
    "x_phases_to_dump_before":     struct(
        flag = "-Xphases-to-dump-before",
        args = dict(
            doc = "Dump the backend's state before these phases.",
                default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-Xphases-to-dump-before"),
    ),
    "x_phases_to_validate":     struct(
        flag = "-Xphases-to-validate",
        args = dict(
            doc = "Validate the backend's state both before and after these phases.",
                default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-Xphases-to-validate"),
    ),
    "x_phases_to_validate_after":     struct(
        flag = "-Xphases-to-validate-after",
        args = dict(
            doc = "Validate the backend's state after these phases.",
                default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-Xphases-to-validate-after"),
    ),
    "x_phases_to_validate_before":     struct(
        flag = "-Xphases-to-validate-before",
        args = dict(
            doc = "Validate the backend's state before these phases.",
                default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-Xphases-to-validate-before"),
    ),
    "x_profile_phases":     struct(
        flag = "-Xprofile-phases",
        args = dict(
            doc = "Profile backend phases.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xprofile-phases"]},
    ),
    "x_render_internal_diagnostic_names":     struct(
        flag = "-Xrender-internal-diagnostic-names",
        args = dict(
            doc = "Render the internal names of warnings and errors.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xrender-internal-diagnostic-names"]},
    ),
    "x_report_all_warnings":     struct(
        flag = "-Xreport-all-warnings",
        args = dict(
            doc = "Report all warnings even if errors are found.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xreport-all-warnings"]},
    ),
    "x_report_output_files":     struct(
        flag = "-Xreport-output-files",
        args = dict(
            doc = "Report the source-to-output file mapping.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xreport-output-files"]},
    ),
    "x_report_perf":     struct(
        flag = "-Xreport-perf",
        args = dict(
            doc = "Report detailed performance statistics.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xreport-perf"]},
    ),
    "x_sam_conversions":     struct(
        flag = "-Xsam-conversions",
        args = dict(
            doc = """Select the code generation scheme for SAM conversions.
    -Xsam-conversions=indy          Generate SAM conversions using 'invokedynamic' with 'LambdaMetafactory.metafactory'.
    -Xsam-conversions=class         Generate SAM conversions as explicit classes.
    The default value is 'indy'.""",
                values = ["","class", "indy"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xsam-conversions"),
    ),
    "x_sanitize_parentheses":     struct(
        flag = "-Xsanitize-parentheses",
        args = dict(
            doc = """Transform '(' and ')' in method names to some other character sequence.
    This mode can BREAK BINARY COMPATIBILITY and should only be used as a workaround for
    problems with parentheses in identifiers on certain platforms.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xsanitize-parentheses"]},
    ),
    "x_serialize_ir":     struct(
        flag = "-Xserialize-ir",
        args = dict(
            doc = "Save the IR to metadata (Experimental).",
                values = ["","none", "inline", "all"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xserialize-ir"),
    ),
    "x_skip_metadata_version_check":     struct(
        flag = "-Xskip-metadata-version-check",
        args = dict(
            doc = "Allow loading classes with bad metadata versions and pre-release classes.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xskip-metadata-version-check"]},
    ),
    "x_skip_prerelease_check":     struct(
        flag = "-Xskip-prerelease-check",
        args = dict(
            doc = "Allow loading pre-release classes.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xskip-prerelease-check"]},
    ),
    "x_string_concat":     struct(
        flag = "-Xstring-concat",
        args = dict(
            doc = """Select the code generation scheme for string concatenation:
    -Xstring-concat=indy-with-constants  Concatenate strings using 'invokedynamic' and 'makeConcatWithConstants'. This requires '-jvm-target 9' or greater.
    -Xstring-concat=indy                 Concatenate strings using 'invokedynamic' and 'makeConcat'. This requires '-jvm-target 9' or greater.
    -Xstring-concat=inline               Concatenate strings using 'StringBuilder'
    default: 'indy-with-constants' for JVM targets 9 or greater, 'inline' otherwise.""",
                values = ["","indy-with-constants", "indy", "inline"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xstring-concat"),
    ),
    "x_support_compatqual_checker_framework_annotations":     struct(
        flag = "-Xsupport-compatqual-checker-framework-annotations",
        args = dict(
            doc = """Specify the behavior for Checker Framework 'compatqual' annotations ('NullableDecl'/'NonNullDecl').
    The default value is 'enable'.""",
                default = "",
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xsupport-compatqual-checker-framework-annotations"),
    ),
    "x_suppress_api_version_greater_than_language_version_error":     struct(
        flag = "-Xsuppress-api-version-greater-than-language-version-error",
        args = dict(
            doc = """Suppress error about API version greater than language version.
    Warning: This is temporary solution (see KT-63712) intended to be used only for stdlib build.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xsuppress-api-version-greater-than-language-version-error"]},
    ),
    "x_suppress_deprecated_jvm_target_warning":     struct(
        flag = "-Xsuppress-deprecated-jvm-target-warning",
        args = dict(
            doc = """Suppress warnings about deprecated JVM target versions.
    This option has no effect and will be deleted in a future version.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xsuppress-deprecated-jvm-target-warning"]},
    ),
    "x_suppress_missing_builtins_error":     struct(
        flag = "-Xsuppress-missing-builtins-error",
        args = dict(
            doc = """Suppress the "cannot access built-in declaration" error (useful with '-no-stdlib').""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xsuppress-missing-builtins-error"]},
    ),
    "x_suppress_version_warnings":     struct(
        flag = "-Xsuppress-version-warnings",
        args = dict(
            doc = "Suppress warnings about outdated, inconsistent, or experimental language or API versions.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xsuppress-version-warnings"]},
    ),
    "x_type_enhancement_improvements_strict_mode":     struct(
        flag = "-Xtype-enhancement-improvements-strict-mode",
        args = dict(
            doc = """Enable strict mode for improvements to type enhancement for loaded Java types based on nullability annotations,
    including the ability to read type-use annotations from class files.
    See KT-45671 for more details.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xtype-enhancement-improvements-strict-mode"]},
    ),
    "x_unrestricted_builder_inference":     struct(
        flag = "-Xunrestricted-builder-inference",
        args = dict(
            doc = "Eliminate builder inference restrictions, for example by allowing type variables to be returned from builder inference calls.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xunrestricted-builder-inference"]},
    ),
    "x_use_14_inline_classes_mangling_scheme":     struct(
        flag = "-Xuse-14-inline-classes-mangling-scheme",
        args = dict(
            doc = "Use the scheme for inline class mangling from version 1.4 instead of the one from 1.4.30.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xuse-14-inline-classes-mangling-scheme"]},
    ),
    "x_use_fast_jar_file_system":     struct(
        flag = "-Xuse-fast-jar-file-system",
        args = dict(
            doc = "Use the fast implementation of Jar FS. This may speed up compilation time, but it is experimental.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xuse-fast-jar-file-system"]},
    ),
    "x_use_fir_ic":     struct(
        flag = "-Xuse-fir-ic",
        args = dict(
            doc = """Compile using frontend IR internal incremental compilation.
    Warning: This feature is not yet production-ready.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xuse-fir-ic"]},
    ),
    "x_use_fir_lt":     struct(
        flag = "-Xuse-fir-lt",
        args = dict(
            doc = "Compile using the LightTree parser with the frontend IR.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xuse-fir-lt"]},
    ),
    "x_use_inline_scopes_numbers":     struct(
        flag = "-Xuse-inline-scopes-numbers",
        args = dict(
            doc = "Use inline scopes numbers for inline marker variables.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xuse-inline-scopes-numbers"]},
    ),
    "x_use_old_class_files_reading":     struct(
        flag = "-Xuse-old-class-files-reading",
        args = dict(
            doc = """Use the old implementation for reading class files. This may slow down the compilation and cause problems with Groovy interop.
    This can be used in the event of problems with the new implementation.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xuse-old-class-files-reading"]},
    ),
    "x_use_type_table":     struct(
        flag = "-Xuse-type-table",
        args = dict(
            doc = "Use a type table in metadata serialization.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xuse-type-table"]},
    ),
    "x_validate_bytecode":     struct(
        flag = "-Xvalidate-bytecode",
        args = dict(
            doc = "Validate generated JVM bytecode before and after optimizations.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xvalidate-bytecode"]},
    ),
    "x_value_classes":     struct(
        flag = "-Xvalue-classes",
        args = dict(
            doc = "Enable experimental value classes.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xvalue-classes"]},
    ),
    "x_verbose_phases":     struct(
        flag = "-Xverbose-phases",
        args = dict(
            doc = "Be verbose while performing the given backend phases.",
                default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-Xverbose-phases"),
    ),
    "api_version":     struct(
        flag = "-api-version",
        args = dict(
            doc = "Allow using declarations from only the specified version of bundled libraries.",
                default = "",
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-api-version"),
    ),
    "java_parameters":     struct(
        flag = "-java-parameters",
        args = dict(
            doc = "Generate metadata for Java 1.8 reflection on method parameters.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-java-parameters"]},
    ),
    "language_version":     struct(
        flag = "-language-version",
        args = dict(
            doc = "Provide source compatibility with the specified version of Kotlin.",
                default = "",
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-language-version"),
    ),
    "opt_in":     struct(
        flag = "-opt-in",
        args = dict(
            doc = "Enable API usages that require opt-in with an opt-in requirement marker with the given fully qualified name.",
                default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-opt-in"),
    ),
    "progressive":     struct(
        flag = "-progressive",
        args = dict(
            doc = """Enable progressive compiler mode.
    In this mode, deprecations and bug fixes for unstable code take effect immediately
    instead of going through a graceful migration cycle.
    Code written in progressive mode is backward compatible; however, code written without
    progressive mode enabled may cause compilation errors in progressive mode.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-progressive"]},
    ),
    "verbose":     struct(
        flag = "-verbose",
        args = dict(
            doc = "Enable verbose logging output.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-verbose"]},
    )
}

# Copyright 2026 The Bazel Authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# DO NOT EDIT: generated by bazel run //src/main/kotlin/io/bazel/kotlin/generate:kotlin_release_options

def _map_string_flag(flag):
    """Create a mapper for string flags that passes value as flag=value."""

    def mapper(value):
        if not value:
            return None
        return [flag + "=" + value]

    return mapper

def _map_string_list_flag(flag):
    """Create a mapper for string list flags that passes each value as flag=value."""

    def mapper(values):
        if not values:
            return None
        return [flag + "=" + v for v in values]

    return mapper

GENERATED_KOPTS = {
    "java_parameters": struct(
        flag = "-java-parameters",
        args = dict(
            doc = "Generate metadata for Java 1.8 reflection on method parameters.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-java-parameters"]},
    ),
    "jvm_default": struct(
        flag = "-jvm-default",
        args = dict(
            doc = """Emit JVM default methods for interface declarations with bodies. The default is 'enable'.
    -jvm-default=enable              Generate default methods for non-abstract interface declarations, as well as 'DefaultImpls' classes with
                                     static methods for compatibility with code compiled in the 'disable' mode.
                                     This is the default behavior since language version 2.2.
    -jvm-default=no-compatibility    Generate default methods for non-abstract interface declarations. Do not generate 'DefaultImpls' classes.
    -jvm-default=disable             Do not generate JVM default methods. This is the default behavior up to language version 2.1.""",
            values = ["", "enable", "no-compatibility", "disable"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-jvm-default"),
    ),
    "jvm_target": struct(
        flag = "-jvm-target",
        args = dict(
            doc = "The target version of the generated JVM bytecode (1.8 and 9–25), with 1.8 as the default.",
            default = "",
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-jvm-target"),
    ),
    "no_reflect": struct(
        flag = "-no-reflect",
        args = dict(
            doc = "Don't automatically include the Kotlin reflection dependency in the classpath.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-no-reflect"]},
    ),
    "x_abi_stability": struct(
        flag = "-Xabi-stability",
        args = dict(
            doc = """When using unstable compiler features such as FIR, use 'stable' to mark generated class files as stable
    to prevent diagnostics from being reported when using stable compilers at the call site.
    When using the JVM IR backend, conversely, use 'unstable' to mark generated class files as unstable
    to force diagnostics to be reported.""",
            values = ["", "stable", "unstable"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xabi-stability"),
    ),
    "x_add_modules": struct(
        flag = "-Xadd-modules",
        args = dict(
            doc = "Root modules to resolve in addition to the initial modules, or all modules on the module path if <module> is ALL-MODULE-PATH.",
            default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-Xadd-modules"),
    ),
    "x_allow_no_source_files": struct(
        flag = "-Xallow-no-source-files",
        args = dict(
            doc = "Allow the set of source files to be empty.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xallow-no-source-files"]},
    ),
    "x_allow_unstable_dependencies": struct(
        flag = "-Xallow-unstable-dependencies",
        args = dict(
            doc = "Do not report errors on classes in dependencies that were compiled by an unstable version of the Kotlin compiler.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xallow-unstable-dependencies"]},
    ),
    "x_annotations_in_metadata": struct(
        flag = "-Xannotations-in-metadata",
        args = dict(
            doc = "Write annotations on declarations into the metadata (in addition to the JVM bytecode), and read annotations from the metadata if they are present.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xannotations-in-metadata"]},
    ),
    "x_assertions": struct(
        flag = "-Xassertions",
        args = dict(
            doc = """'kotlin.assert' call behavior:
    -Xassertions=always-enable:  enable, ignore JVM assertion settings;
    -Xassertions=always-disable: disable, ignore JVM assertion settings;
    -Xassertions=jvm:            enable, depend on JVM assertion settings;
    -Xassertions=legacy:         calculate the condition on each call, the behavior depends on JVM assertion settings in the kotlin package;
    default: legacy""",
            values = ["", "always-enable", "always-disable", "jvm", "legacy"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xassertions"),
    ),
    "x_backend_threads": struct(
        flag = "-Xbackend-threads",
        args = dict(
            doc = """Run codegen phase in N parallel threads.
    0 means use one thread per processor core.
    The default value is 1.""",
            default = "1",
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xbackend-threads"),
    ),
    "x_compile_builtins_as_part_of_stdlib": struct(
        flag = "-Xcompile-builtins-as-part-of-stdlib",
        args = dict(
            doc = "Enable behaviour needed to compile builtins as part of JVM stdlib",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xcompile-builtins-as-part-of-stdlib"]},
    ),
    "x_compile_java": struct(
        flag = "-Xcompile-java",
        args = dict(
            doc = "Reuse 'javac' analysis and compile Java source files.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xcompile-java"]},
    ),
    "x_debug": struct(
        flag = "-Xdebug",
        args = dict(
            doc = """Enable debug mode for compilation.
    Currently this includes spilling all variables in a suspending context regardless of whether they are alive.
    If API Level >= 2.2 -- no-op.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xdebug"]},
    ),
    "x_default_script_extension": struct(
        flag = "-Xdefault-script-extension",
        args = dict(
            doc = "Compile expressions and unrecognized scripts passed with the -script argument as scripts with the given filename extension.",
            default = "",
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xdefault-script-extension"),
    ),
    "x_disable_standard_script": struct(
        flag = "-Xdisable-standard-script",
        args = dict(
            doc = "Disable standard Kotlin scripting support.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xdisable-standard-script"]},
    ),
    "x_emit_jvm_type_annotations": struct(
        flag = "-Xemit-jvm-type-annotations",
        args = dict(
            doc = "Emit JVM type annotations in bytecode.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xemit-jvm-type-annotations"]},
    ),
    "x_enhance_type_parameter_types_to_def_not_null": struct(
        flag = "-Xenhance-type-parameter-types-to-def-not-null",
        args = dict(
            doc = "Enhance not-null-annotated type parameter types to definitely-non-nullable types ('@NotNull T' => 'T & Any').",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xenhance-type-parameter-types-to-def-not-null"]},
    ),
    "x_enhanced_coroutines_debugging": struct(
        flag = "-Xenhanced-coroutines-debugging",
        args = dict(
            doc = """Generate additional linenumber instruction for compiler-generated code
    inside suspend functions and lambdas to distinguish them from user code by debugger.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xenhanced-coroutines-debugging"]},
    ),
    "x_generate_strict_metadata_version": struct(
        flag = "-Xgenerate-strict-metadata-version",
        args = dict(
            doc = "Generate metadata with strict version semantics (see the KDoc entry on 'Metadata.extraInt').",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xgenerate-strict-metadata-version"]},
    ),
    "x_indy_allow_annotated_lambdas": struct(
        flag = "-Xindy-allow-annotated-lambdas",
        args = dict(
            doc = "Allow using 'invokedynamic' for lambda expressions with annotations",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xindy-allow-annotated-lambdas"]},
    ),
    "x_ir_do_not_clear_binding_context": struct(
        flag = "-Xir-do-not-clear-binding-context",
        args = dict(
            doc = "When using the IR backend, do not clear BindingContext between 'psi2ir' and lowerings.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xir-do-not-clear-binding-context"]},
    ),
    "x_ir_inliner": struct(
        flag = "-Xir-inliner",
        args = dict(
            doc = "Inline functions using the IR inliner instead of the bytecode inliner.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xir-inliner"]},
    ),
    "x_java_package_prefix": struct(
        flag = "-Xjava-package-prefix",
        args = dict(
            doc = "Package prefix for Java files.",
            default = "",
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xjava-package-prefix"),
    ),
    "x_jdk_release": struct(
        flag = "-Xjdk-release",
        args = dict(
            doc = """Compile against the specified JDK API version, similarly to javac's '-release'. This requires JDK 9 or newer.
    The supported versions depend on the JDK used; for JDK 17+, the supported versions are 1.8 and 9–25.
    This also sets the value of '-jvm-target' to be equal to the selected JDK version.""",
            default = "",
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xjdk-release"),
    ),
    "x_jspecify_annotations": struct(
        flag = "-Xjspecify-annotations",
        args = dict(
            doc = """Specify the behavior of 'jspecify' annotations.
    The default value is 'strict'.""",
            values = ["", "ignore", "strict", "warn"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xjspecify-annotations"),
    ),
    "x_jsr305": struct(
        flag = "-Xjsr305",
        args = dict(
            doc = """Specify the behavior of 'JSR-305' nullability annotations:
    -Xjsr305={ignore/strict/warn}                   global (all non-@UnderMigration annotations)
    -Xjsr305=under-migration:{ignore/strict/warn}   all @UnderMigration annotations
    -Xjsr305=@<fq.name>:{ignore/strict/warn}        annotation with the given fully qualified class name
    Modes:
    * ignore
    * strict (experimental; treat like other supported nullability annotations)
    * warn (report a warning)""",
            default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-Xjsr305"),
    ),
    "x_jvm_default": struct(
        flag = "-Xjvm-default",
        args = dict(
            doc = """This option is deprecated. Migrate to -jvm-default as follows:
    -Xjvm-default=disable            -> -jvm-default=disable
    -Xjvm-default=all-compatibility  -> -jvm-default=enable
    -Xjvm-default=all                -> -jvm-default=no-compatibility""",
            values = ["", "disable", "all-compatibility", "all"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xjvm-default"),
    ),
    "x_jvm_enable_preview": struct(
        flag = "-Xjvm-enable-preview",
        args = dict(
            doc = """Allow using Java features that are in the preview phase.
    This works like '--enable-preview' in Java. All class files are marked as compiled with preview features, meaning it won't be possible to use them in release environments.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xjvm-enable-preview"]},
    ),
    "x_jvm_expose_boxed": struct(
        flag = "-Xjvm-expose-boxed",
        args = dict(
            doc = "Expose inline classes and functions, accepting and returning them, to Java.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xjvm-expose-boxed"]},
    ),
    "x_klib": struct(
        flag = "-Xklib",
        args = dict(
            doc = "Paths to cross-platform libraries in the .klib format.",
            default = "",
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xklib"),
    ),
    "x_lambdas": struct(
        flag = "-Xlambdas",
        args = dict(
            doc = """Select the code generation scheme for lambdas.
    -Xlambdas=indy                  Generate lambdas using 'invokedynamic' with 'LambdaMetafactory.metafactory'.
                                    A lambda object created using 'LambdaMetafactory.metafactory' will have a different 'toString()'.
    -Xlambdas=class                 Generate lambdas as explicit classes.
    The default value is 'indy' if language version is 2.0+, and 'class' otherwise.""",
            values = ["", "class", "indy"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xlambdas"),
    ),
    "x_link_via_signatures": struct(
        flag = "-Xlink-via-signatures",
        args = dict(
            doc = """Link JVM IR symbols via signatures instead of descriptors.
    This mode is slower, but it can be useful for troubleshooting problems with the JVM IR backend.
    This option is deprecated and will be deleted in future versions.
    It has no effect when -language-version is 2.0 or higher.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xlink-via-signatures"]},
    ),
    "x_module_path": struct(
        flag = "-Xmodule-path",
        args = dict(
            doc = "Paths to Java 9+ modules.",
            default = "",
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xmodule-path"),
    ),
    "x_multifile_parts_inherit": struct(
        flag = "-Xmultifile-parts-inherit",
        args = dict(
            doc = "Compile multifile classes as a hierarchy of parts and a facade.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xmultifile-parts-inherit"]},
    ),
    "x_no_call_assertions": struct(
        flag = "-Xno-call-assertions",
        args = dict(
            doc = "Don't generate not-null assertions for arguments of platform types.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-call-assertions"]},
    ),
    "x_no_new_java_annotation_targets": struct(
        flag = "-Xno-new-java-annotation-targets",
        args = dict(
            doc = "Don't generate Java 1.8+ targets for Kotlin annotation classes.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-new-java-annotation-targets"]},
    ),
    "x_no_optimize": struct(
        flag = "-Xno-optimize",
        args = dict(
            doc = "Disable optimizations.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-optimize"]},
    ),
    "x_no_param_assertions": struct(
        flag = "-Xno-param-assertions",
        args = dict(
            doc = "Don't generate not-null assertions on parameters of methods accessible from Java.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-param-assertions"]},
    ),
    "x_no_receiver_assertions": struct(
        flag = "-Xno-receiver-assertions",
        args = dict(
            doc = "Don't generate not-null assertions for extension receiver arguments of platform types.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-receiver-assertions"]},
    ),
    "x_no_reset_jar_timestamps": struct(
        flag = "-Xno-reset-jar-timestamps",
        args = dict(
            doc = "Don't reset jar entry timestamps to a fixed date.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-reset-jar-timestamps"]},
    ),
    "x_no_source_debug_extension": struct(
        flag = "-Xno-source-debug-extension",
        args = dict(
            doc = "Don't generate the '@kotlin.jvm.internal.SourceDebugExtension' annotation with an SMAP copy on classes.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-source-debug-extension"]},
    ),
    "x_no_unified_null_checks": struct(
        flag = "-Xno-unified-null-checks",
        args = dict(
            doc = "Use pre-1.4 exception types instead of 'java.lang.NPE' in null checks. See KT-22275 for more details.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xno-unified-null-checks"]},
    ),
    "x_nullability_annotations": struct(
        flag = "-Xnullability-annotations",
        args = dict(
            doc = """Specify the behavior for specific Java nullability annotations (provided with fully qualified package name).
    Modes:
    * ignore
    * strict
    * warn (report a warning)""",
            default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-Xnullability-annotations"),
    ),
    "x_output_builtins_metadata": struct(
        flag = "-Xoutput-builtins-metadata",
        args = dict(
            doc = "Output builtins metadata as .kotlin_builtins files",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xoutput-builtins-metadata"]},
    ),
    "x_profile": struct(
        flag = "-Xprofile",
        args = dict(
            doc = """Debug option: Run the compiler with the async profiler and save snapshots to `outputDir`; `command` is passed to the async profiler on start.
    `profilerPath` is the path to libasyncProfiler.so; async-profiler.jar should be on the compiler classpath.
    If it's not on the classpath, the compiler will attempt to load async-profiler.jar from the containing directory of profilerPath.
    Example: -Xprofile=<PATH_TO_ASYNC_PROFILER>/async-profiler/build/libasyncProfiler.so:event=cpu,interval=1ms,threads,start:<SNAPSHOT_DIR_PATH>""",
            default = "",
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xprofile"),
    ),
    "x_sam_conversions": struct(
        flag = "-Xsam-conversions",
        args = dict(
            doc = """Select the code generation scheme for SAM conversions.
    -Xsam-conversions=indy          Generate SAM conversions using 'invokedynamic' with 'LambdaMetafactory.metafactory'.
    -Xsam-conversions=class         Generate SAM conversions as explicit classes.
    The default value is 'indy'.""",
            values = ["", "class", "indy"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xsam-conversions"),
    ),
    "x_sanitize_parentheses": struct(
        flag = "-Xsanitize-parentheses",
        args = dict(
            doc = """Transform '(' and ')' in method names to some other character sequence.
    This mode can BREAK BINARY COMPATIBILITY and should only be used as a workaround for
    problems with parentheses in identifiers on certain platforms.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xsanitize-parentheses"]},
    ),
    "x_script_resolver_environment": struct(
        flag = "-Xscript-resolver-environment",
        args = dict(
            doc = "Set the script resolver environment in key-value pairs (the value can be quoted and escaped).",
            default = [],
        ),
        type = attr.string_list,
        value_to_flag = None,
        map_value_to_flag = _map_string_list_flag("-Xscript-resolver-environment"),
    ),
    "x_serialize_ir": struct(
        flag = "-Xserialize-ir",
        args = dict(
            doc = "Save the IR to metadata (Experimental).",
            values = ["", "none", "inline", "all"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xserialize-ir"),
    ),
    "x_string_concat": struct(
        flag = "-Xstring-concat",
        args = dict(
            doc = """Select the code generation scheme for string concatenation:
    -Xstring-concat=indy-with-constants  Concatenate strings using 'invokedynamic' and 'makeConcatWithConstants'. This requires '-jvm-target 9' or greater.
    -Xstring-concat=indy                 Concatenate strings using 'invokedynamic' and 'makeConcat'. This requires '-jvm-target 9' or greater.
    -Xstring-concat=inline               Concatenate strings using 'StringBuilder'
    default: 'indy-with-constants' for JVM targets 9 or greater, 'inline' otherwise.""",
            values = ["", "indy-with-constants", "indy", "inline"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xstring-concat"),
    ),
    "x_support_compatqual_checker_framework_annotations": struct(
        flag = "-Xsupport-compatqual-checker-framework-annotations",
        args = dict(
            doc = """Specify the behavior for Checker Framework 'compatqual' annotations ('NullableDecl'/'NonNullDecl').
    The default value is 'enable'.""",
            values = ["", "enable", "disable"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xsupport-compatqual-checker-framework-annotations"),
    ),
    "x_suppress_deprecated_jvm_target_warning": struct(
        flag = "-Xsuppress-deprecated-jvm-target-warning",
        args = dict(
            doc = """Suppress warnings about deprecated JVM target versions.
    This option has no effect and will be deleted in a future version.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xsuppress-deprecated-jvm-target-warning"]},
    ),
    "x_suppress_missing_builtins_error": struct(
        flag = "-Xsuppress-missing-builtins-error",
        args = dict(
            doc = """Suppress the "cannot access built-in declaration" error (useful with '-no-stdlib').""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xsuppress-missing-builtins-error"]},
    ),
    "x_type_enhancement_improvements_strict_mode": struct(
        flag = "-Xtype-enhancement-improvements-strict-mode",
        args = dict(
            doc = """Enable strict mode for improvements to type enhancement for loaded Java types based on nullability annotations,
    including the ability to read type-use annotations from class files.
    See KT-45671 for more details.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xtype-enhancement-improvements-strict-mode"]},
    ),
    "x_use_14_inline_classes_mangling_scheme": struct(
        flag = "-Xuse-14-inline-classes-mangling-scheme",
        args = dict(
            doc = "Use the scheme for inline class mangling from version 1.4 instead of the one from 1.4.30.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xuse-14-inline-classes-mangling-scheme"]},
    ),
    "x_use_fast_jar_file_system": struct(
        flag = "-Xuse-fast-jar-file-system",
        args = dict(
            doc = "Use the fast implementation of Jar FS. This may speed up compilation time, but it is experimental.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xuse-fast-jar-file-system"]},
    ),
    "x_use_inline_scopes_numbers": struct(
        flag = "-Xuse-inline-scopes-numbers",
        args = dict(
            doc = "Use inline scopes numbers for inline marker variables.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xuse-inline-scopes-numbers"]},
    ),
    "x_use_javac": struct(
        flag = "-Xuse-javac",
        args = dict(
            doc = "Use javac for Java source and class file analysis.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xuse-javac"]},
    ),
    "x_use_k2_kapt": struct(
        flag = "-Xuse-k2-kapt",
        args = dict(
            doc = "Enable the experimental support for K2 KAPT.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xuse-k2-kapt"]},
    ),
    "x_use_old_class_files_reading": struct(
        flag = "-Xuse-old-class-files-reading",
        args = dict(
            doc = """Use the old implementation for reading class files. This may slow down the compilation and cause problems with Groovy interop.
    This can be used in the event of problems with the new implementation.""",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xuse-old-class-files-reading"]},
    ),
    "x_use_type_table": struct(
        flag = "-Xuse-type-table",
        args = dict(
            doc = "Use a type table in metadata serialization.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xuse-type-table"]},
    ),
    "x_validate_bytecode": struct(
        flag = "-Xvalidate-bytecode",
        args = dict(
            doc = "Validate generated JVM bytecode before and after optimizations.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xvalidate-bytecode"]},
    ),
    "x_value_classes": struct(
        flag = "-Xvalue-classes",
        args = dict(
            doc = "Enable experimental value classes.",
        ),
        type = attr.bool,
        value_to_flag = {True: ["-Xvalue-classes"]},
    ),
    "x_when_expressions": struct(
        flag = "-Xwhen-expressions",
        args = dict(
            doc = """Select the code generation scheme for type-checking 'when' expressions:
    -Xwhen-expressions=indy         Generate type-checking 'when' expressions using 'invokedynamic' with 'SwitchBootstraps.typeSwitch(..)' and 
                                    following 'tableswitch' or 'lookupswitch'. This requires '-jvm-target 21' or greater.
    -Xwhen-expressions=inline       Generate type-checking 'when' expressions as a chain of type checks.
    The default value is 'inline'.""",
            values = ["", "indy", "inline"],
        ),
        type = attr.string,
        value_to_flag = None,
        map_value_to_flag = _map_string_flag("-Xwhen-expressions"),
    ),
}
